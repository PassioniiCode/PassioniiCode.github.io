<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code Ant&#39;s Blog</title>
  
  <subtitle>“每天进步一点点”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lijinhongpassion.github.io/"/>
  <updated>2020-03-17T07:18:34.169Z</updated>
  <id>https://lijinhongpassion.github.io/</id>
  
  <author>
    <name>Code Ant</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代写课程/毕设（包售后、远程调试）</title>
    <link href="https://lijinhongpassion.github.io/codeant/kcsj.html"/>
    <id>https://lijinhongpassion.github.io/codeant/kcsj.html</id>
    <published>2020-12-30T08:04:28.000Z</published>
    <updated>2020-03-17T07:18:34.169Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/kcsj/bd.webp" alt></p><a id="more"></a><hr><h1 id="目录见右下脚（看具体的毕设系统），联系方式见文末"><a href="#目录见右下脚（看具体的毕设系统），联系方式见文末" class="headerlink" title="目录见右下脚（看具体的毕设系统），联系方式见文末"></a><font color="#dd0000">目录见右下脚（看具体的毕设系统），联系方式见文末</font></h1><h1 id="页面中图片加载较慢，请耐心等待"><a href="#页面中图片加载较慢，请耐心等待" class="headerlink" title="页面中图片加载较慢，请耐心等待"></a><font color="#dd0000">页面中图片加载较慢，请耐心等待</font></h1><h1 id="写在前面（必读）"><a href="#写在前面（必读）" class="headerlink" title="写在前面（必读）"></a>写在前面（必读）</h1><p><strong>各毕设中使用的技术和系统用处不一定准确和全面，具体使用技术建议参考代码。</strong></p><p>文中的各毕设不一定每一个都非常的完美，有些包含代码+论文，选其中一个自己觉得不错的，用来做毕设。</p><p><strong>论文可以参考，但是不建议直接照搬，因为毕竟要查重</strong></p><h2 id="各毕设开发环境"><a href="#各毕设开发环境" class="headerlink" title="各毕设开发环境"></a>各毕设开发环境</h2><p>由于各个毕设的开发环境可能不同，包括各种编辑器，如：<code>IDEA</code>、<code>Eclipse</code>、<code>MyEclipse</code>，数据库：<code>Mysql</code>、<code>SQL Server</code>、<code>Oracle</code>等。</p><h1 id="业务范围"><a href="#业务范围" class="headerlink" title="业务范围"></a>业务范围</h1><p><strong>业务范围为：</strong></p><ul><li>Java<strong>课程设计</strong>（拥有大量的成品 <strong>【 源码+论文 】</strong>）<ul><li>Java web<strong>毕业设计</strong><ul><li>Python爬虫<ul><li>C/C++<ul><li><strong>大学各种小作业</strong>（sql编写、uml、html、计算机网络、数据结构、网络协议等大量成品）<ul><li><strong><font color="#dd0000">Java web商业单请加微信详谈</font> </strong></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p><strong>学习资料有偿分享：</strong></p><p><strong>电脑实用工具：</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/kcsj/技巧工具.png" alt></p><p><strong>PPT成套模板：</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/kcsj/ppt.png" alt></p><p><strong>技术视频：</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/kcsj/视频.png" alt></p><h1 id="毕业设计项目介绍"><a href="#毕业设计项目介绍" class="headerlink" title="毕业设计项目介绍"></a>毕业设计项目<strong>介绍</strong></h1><p>各毕业设计项目将按行业进行分类，从中选取你想选择的毕业设计即可。</p><p>产品保证能够正常运行</p><h2 id="互联网和移动互联网"><a href="#互联网和移动互联网" class="headerlink" title="[ 互联网和移动互联网 ]"></a>[ 互联网和移动互联网 ]</h2><hr><h3 id="项目一：jsp网上招标系统"><a href="#项目一：jsp网上招标系统" class="headerlink" title="项目一：jsp网上招标系统"></a>项目一：jsp网上招标系统</h3><p><strong>介绍</strong></p><blockquote><p>jsp网上招标系统主要用于实现会员的发布任务和接收任务的功能，<br>基本功能包括<br>（1）注册用户部分<br>  1：查看网站流程：查看与网站有关的流程信息，及相关的新闻公告。<br>  2：发布网站留言信息：根据系统提示，发布网站的留言信息。<br>  3：查看已发布的信息：以列表的形式查看已发布信息。<br>  4：发布威客在线信息：根据系统提示，发布网站的留言信息。<br>  5：查看网站成交记录：根据系统提示，查看成交记录信息。</p><p>（2） 管理员部分<br>  1：编辑系统用户信息：添加、编辑用户信息，包括发布者和管理员，以列表的形式显示；<br>  2：编辑网站留言信息：以列表的形式显示网站留言信息，并可对其进行删除等编辑操作；<br>  3：数据备份：不定期进行系统数据备份，以防万一。</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用的技术</strong>：Servlet + JDBC+ JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目二：城市公交查询系统"><a href="#项目二：城市公交查询系统" class="headerlink" title="项目二：城市公交查询系统"></a>项目二：城市公交查询系统</h3><p><strong>介绍</strong></p><blockquote><p>我国许多城市都有一些颇具设计感的公交站台,但我们却很难在这里找到我们出行需要的信息。因此，居民想要找到“静态线路信息”或者“动态实时信息”都感到十分困难。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用的技术：</strong>Servlet + JDBC+ JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目三：基于JSP动漫论坛"><a href="#项目三：基于JSP动漫论坛" class="headerlink" title="项目三：基于JSP动漫论坛"></a>项目三：基于JSP动漫论坛</h3><p><strong>介绍</strong></p><blockquote><p>动漫论坛项目主要用于实现动漫爱好者的互相交流，基本功能包括：注册用户、登录、浏览帖子、发布新帖、回复帖子、等。本系统结构如下：<br>（1）普通用户：<br>  注册用户：如果用户为非会员用户，通过注册，经审核通过之后成为会员，获得一个登陆身份；<br>  登录：如果用户已经是注册会员，可以进行登录，登陆后实现别的功能；<br>  浏览帖子：用户查看系统中的帖子，了解最新的资讯和各种动态等信息；<br>  发布新帖：用户可以发表一些帖子，来与其他论坛用户共享信息；<br>  回复帖子：对于自己或者别的会员发表的帖子，可以进行回复。<br>（2）管理员：<br>  管理员登录：对于已经登录的用户，若权限为管理员，可以进行管理员的登录，登陆之后才能有权限进行下一步操作；<br>  帖子管理：管理员可以对发表的帖子进行查询、修改、删除等操作，对好的帖子进行标识，删除或转移不适合的帖子；<br>  模块管理：论坛中的模块，管理员可对其进行添加、修改、删除等操作；<br>  用户管理：用户注册成功后，管理员可以对用户进行添加、删除操作。<br>（3）游客：<br>  游客可以对论坛进行访问，浏览帖子的功能，但不能参与回复操作，也没有发布帖子的权限。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Struts 1 + JDBC+ JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目四：个人博客系统"><a href="#项目四：个人博客系统" class="headerlink" title="项目四：个人博客系统"></a>项目四：个人博客系统</h3><p><strong>介绍</strong></p><blockquote><p>个人博客系统主要用于发表个人博客，记录个人生活日常，学习心得，技术分享等，供他人浏览，查阅，评论等。</p><p>（1）博主端：<br>  登录模块：登入后台管理系统：首先进入登录页面，需要输入账号和密码。它会使用Shiro进行安全管理，对前台输入的密码进行加密运算，然后与数据库中的进行比较。成功后才能登入后台系统。<br>  博客管理模块：博客管理功能分为写博客和博客信息管理。写博客是博主用来发表编写博客的，需要博客标题，然后选择博客类型，最后将博客内容填入百度的富文本编辑器中，点击发布博客按钮即可发布博客。<br>  博客类别管理模块：博主类别管理系统可以添加，修改和删除博客类型名称和排序序号。将会显示到首页的按日志类别区域。 游客可以从这里查找相关的感兴趣的博客内容<br>  评论信息管理模块：评论管理功能分为评论审核和评论信息管理两部分。评论审核是当有游客或自己发表了评论之后，博主需要在后台管理系统中审核评论。若想将此评论显示在页面上则点击审核通过，否则点击审核不通过。<br>  个人信息管理模块：修改博主的个人信息，可以修改昵称，个性签名，可以添加个人头像，修改个人简介；<br>  系统管理功能模块：友情<strong>链接</strong>管理，修改密码，刷新系统缓存和安全退出，友情<strong>链接</strong>管理可以添加，修改，删除友情<strong>链接</strong>网址<br>（2）游客端：<br>  查询博客：查询具体哪一篇博客<br>  查看博客内容：查看博客内容<br>  查看博主个人信息：查看博主个人简介<br>  发表评论：可以评论具体某篇博客<br>  友情链接：查看友情<strong>链接</strong></p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Spring + Spring MVC + Mybatis + JSP</li><li><strong>开发工具：</strong>未知</li></ul><hr><h3 id="项目五：网上拍卖系统"><a href="#项目五：网上拍卖系统" class="headerlink" title="项目五：网上拍卖系统"></a>项目五：网上拍卖系统</h3><p><strong>介绍</strong></p><blockquote><p>基于B2C的网上拍卖系统主要用于帮助人们应用互联网方便快捷买到自己所中意的商品，并参与到秒杀与竞拍当中。</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Spring + Struts2 + Hibernate + JSP</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目六：电子书下载系统"><a href="#项目六：电子书下载系统" class="headerlink" title="项目六：电子书下载系统"></a>项目六：电子书下载系统</h3><p><strong>介绍</strong></p><blockquote><p>基于JAVA_JSP电子书下载系统主要用功能包括：</p><p>（1）后台管理:<br>  个人信息管理：实现个密码信息的修改<br>  会员信息管理：实现会员信息的查询、删除<br>  点券充值管理：实现充值信息的查询、审核、删除<br>  类别信息管理：实现图书类别信息增加、删除、修改、查看功能<br>  电子书信息管理：实现电子书信息的增加、删除、修改、查看功能<br>  留言公告管理：实现公告信息的增加、删除、修改、查看功能实现留言信息的查询和删除<br>（2）前台管理：<br>  实现电子书信息的分类查询、作者、书名查询<br>  实现用户信息的注册<br>  实现用户的登录和退出<br>  实现登录用户的留言、重置、书籍下载</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目七：影视创作论坛"><a href="#项目七：影视创作论坛" class="headerlink" title="项目七：影视创作论坛"></a>项目七：影视创作论坛</h3><p><strong>介绍</strong></p><blockquote><p>基于Javaee的影视创作论坛主要用功能包括：</p><p>（1）后台管理:<br>  管理模块：管理员的登录与退出、管理员个人信息的设置<br>  电影管理模块：电影信息的增加、删除、修改、电影分类信息的增加、删除、修改、查看功能<br>  影评管理模块：实现影评信息的增加、删除、修改、查看功能<br>  预告管理模块：实现预告片信息的增加、删除、修改、查看功能<br>  海报管理模块：实现海报信息的增加、删除、修改、查看功能<br>  公告管理模块：实现公告信息的增加、删除、修改、查看功能<br>（2）前台管理：<br>  实现网站首页数据展示、海报展示、预告片浏览、公告预览等<br>  实现电影影评的评论发表、查询评论<br>  站内数据搜索<br>  用户的登录和退出</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目八：Java记账管理系统"><a href="#项目八：Java记账管理系统" class="headerlink" title="项目八：Java记账管理系统"></a>项目八：Java记账管理系统</h3><p><strong>介绍</strong></p><blockquote><p>Java记账管理系统主要用于财务人员可以从账务中判断公司的发展方向。对个人和家庭而言，通过记账可以制定日后的 消费计划，这样才能为理财划出清晰合理的线条。<br>（1）用户注册：<br>  用户通过注册功能注册成功后跳转至登录页面方便登录<br>（2）用户登录：<br>  用户登录成功后：<br>  信息管理：用户可以修改个人的信息<br>  财务管理：用户可以查看自己的财务信息和做一些新的财务记录<br>  财务统计：用户可以查看自己的月收支或年收支，以便做到心里有数<br>（3）管理员登录：<br>  管理员信息管理：可以对管理员信息进行一些基本操作<br>  用户信息管理：可以对用户进行查询和删除等操作，以便管理用户群</p></blockquote><ul><li><strong>数据库：</strong>Oracle</li><li><strong>使用技术：</strong>Servlet + Mybatis + JSP</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目九：新闻发布及管理系统"><a href="#项目九：新闻发布及管理系统" class="headerlink" title="项目九：新闻发布及管理系统"></a>项目九：新闻发布及管理系统</h3><p><strong>介绍</strong></p><blockquote><p>Java新闻发布系统新闻发布及管理系统就是一个能够在网上实现新闻的发布及管理，让人们更好的获取更新的新闻资讯。<br>（1）用户管理：<br>  用户注册：新用户注册<br>  用户登录：新用户登录<br>  找回密码：忘记密码找回密码<br>  用户评论：发表对新闻的评论<br>（2）管理员管理：<br>  系统账号管理：管理员管理系统现有账号，进行删除停用等操作<br>  系统公告管理：系统公告的发布和删除<br>  新闻栏目管理：新闻栏目的新增和删除<br>  新闻资讯管理：新闻资讯的新增和删除<br>  注册用户管理：注册用户的删除和冻结<br>  友情链接管理：添加和删除友情<strong>链接</strong>功能<br>  新闻评论管理：删除用户不当评论</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Servlet + JDBC+ JSP</li><li><strong>开发工具：</strong>未知</li></ul><hr><h3 id="项目十：任务调度系统"><a href="#项目十：任务调度系统" class="headerlink" title="项目十：任务调度系统"></a>项目十：任务调度系统</h3><p><strong>介绍</strong></p><blockquote><p>任务调度试系统，基本功能包括：用户的注册、用户的登录、发起项目、项目详细及搜索等。本系统结构如下：<br>（1）用户的注册登录：<br>  注册模块：完成用户注册功能；<br>  登录模块：完成用户登录功能；<br>（2）发起项目：<br>  发起项目模块：完成了项目及项目下一个或者多个任务的添加；<br>  项目详细:点击项目名称，可以看到项目及任务详细信息;<br>  搜索项目:完成对项目名称的模糊搜索功能</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Spring+ Spring MVC + Hibernate + JSP</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目十一：基于网络爬虫技术的网络新闻分析"><a href="#项目十一：基于网络爬虫技术的网络新闻分析" class="headerlink" title="项目十一：基于网络爬虫技术的网络新闻分析"></a>项目十一：基于网络爬虫技术的网络新闻分析</h3><p><strong>介绍</strong></p><blockquote><p>基于网络爬虫技术的网络新闻分析主要用于网络数据爬取。本系统结构如下：<br>（1）网络爬虫模块。<br>（2）中文分词模块。<br>（3）中3文相似度判定模块。<br>（4）数据结构化存储模块。<br>（5）数据可视化展示模块。</p></blockquote><ul><li><strong>数据库：</strong>无（数据保存方式为直接生成图表）</li><li><strong>使用技术：</strong>HttpClietn + IK分词器 + 相似度算法</li><li><strong>开发工具：</strong>未知</li></ul><hr><h3 id="项目十二：旅游网站设计与实现"><a href="#项目十二：旅游网站设计与实现" class="headerlink" title="项目十二：旅游网站设计与实现"></a>项目十二：旅游网站设计与实现</h3><p><strong>介绍</strong></p><blockquote><p>塞北村镇旅游网站设计主要用于实现旅游景点信息管理，基本功能包括：主界面模块设计，用户注册模块，旅游景点模块，酒店预订模块，后台管理模块等。本系统结构如下：<br>（1）主界模块设计：<br>  首页效果、首页塞北人文、首页酒店信息、首页景点信息、自驾游路线<br>  首页天气预报、在线留言、用户注册、首页后台登录<br>（2）用户注册模块：<br>  用户注册完成后，经过管理员的审核以后方能成功登录。<br>  用户注册成功以后，可以进行预订管理，个人信息管理以及旅游路线管理等功能<br>（3）旅游景点模块：<br>  供用户快速便捷的搜索到自己想要的旅游景点信息。<br>  景点信息展示、景点名称查询、旅游景点效果图，该部分风景的查询与显示。<br>（4）酒店预定模块：<br>  客户登录，可以进行具体资料查看操作。<br>  酒店详细信息、酒店预订、酒店预订成功、酒店预订成功列表所示，可以清晰的展现出酒店订购模块的具体操作和运行效果。<br>（5）后台管理设计：<br>  管理员登录后，可以实施各种操作。实现对网站基本信息的管理。<br>  系统功能列表里主要包括：<br>      1.账号管理，在这里管理员可以修改个人信息，包括密码和个人资料等等。<br>      2.用户注册管理部分是对该网站的申请注册的用户进行验证通过，管理员可以对所有用户进行删除修改和审核。<br>      3.塞北人文添加模块主要是对该网站中塞北人文的管理，管理员可以对塞北人文进行更新修改和删除。<br>      4.塞北故事管理模块。<br>      5.塞北景点进行操作。<br>      6.自驾游路线管理。<br>      7.酒店信息管理模块。<br>      8.留言板管理较为简单。<br>      9.最后包括修改密码和退出登录模块。</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目十三：搜索引擎"><a href="#项目十三：搜索引擎" class="headerlink" title="项目十三：搜索引擎"></a>项目十三：搜索引擎</h3><p><strong>介绍</strong></p><blockquote><p>经过对搜索引擎的研究同时与Lucene自身的特性相结合，搜索引擎需要实现的功能阐述如下：<br>  （1）支持桌面文件搜索,格式包括txt、doc、xls和ppt;<br>  （2）支持分词查询<br>  （3）支持全文搜索<br>  （4）能够高亮显示搜索关键字<br>  （5）显示查询所用的时间<br>  （6）显示搜索历史、过滤关键字</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Lucene + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目十四：网上招聘系统"><a href="#项目十四：网上招聘系统" class="headerlink" title="项目十四：网上招聘系统"></a>项目十四：网上招聘系统</h3><p><strong>介绍</strong></p><blockquote><p>网上招聘系统，包含俩个角色：个人和公司角色。本系统结构如下：个人角色<br>  （1）首页：显示个人可以申请职位的公司信息，实现了查询、申请职位功能<br>  （2）个人信息修改：实现了对个人信息（简历）的修改<br>  （3）下载简历：实现对简历的下载<br>  （4）发布简历<br>  （5）撤销简历<br>  （6）消息通知：实现了对已申请公司是否通过功能<br>公司角色<br>  （1）首页：显示所有申请公司职位的求职者信息<br>  （2）公司信息修改：实现了对公司信息的修改<br>  （3）发布招聘信息<br>  （4）撤销招聘信息<br>  （5）求职者通知：实现了对已申请公司职位的求职者是否通过功能</p></blockquote><ul><li><strong>数据库：</strong>Oracle</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目十五：文章发布系统"><a href="#项目十五：文章发布系统" class="headerlink" title="项目十五：文章发布系统"></a>项目十五：文章发布系统</h3><p><strong>介绍</strong></p><blockquote><p>文章发布系统项目，基本功能包括：网站信息、基础信息、系统管理、个人信息等。本系统结构如下：<br>（1）网站信息：<br>  文章管理：实现添加文章，查询文章功能<br>  文章评论管理：实现根据评论信息查询功能<br>  联系我们：实现对公司信息的修改功能<br>  网站公告:实现对网站公告的修改功能<br>  留言板：实现对留言的回复、删除功能<br>（2）基础信息：<br>  会员管理：实现对会员的显示、查询功能<br>  文章类别管理：实现对文章类别的增加、删除、修改、查询功能<br>（3）系统管理：<br>  添加管理员：实现管理员的添加功能<br>  管理员维护：实现对管理员的修改、删除、查询功能</p><p>（4）个人信息：<br>  基本资料管理：实现对个人资料的修改功能<br>  修改登陆密码：实现修改旧密码功能</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Spring + Struts2 + Hibernate + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目十六：物流信息网"><a href="#项目十六：物流信息网" class="headerlink" title="项目十六：物流信息网"></a>项目十六：物流信息网</h3><p><strong>介绍</strong></p><blockquote><p>物流信息网主要用于实现网上自主物流，基本功能包括：登录、查询、时效查询、价格查询、注册等。本系统结构如下：<br>（1）普通用户：<br>  登录：账号、密码；<br>  查询：通过快递编号进行查询；<br>  时效查询：根据出发地和接收地进行查询；<br>  价格查询：根据出发地，接收地以及重量进行查询；<br>  注册：用户进行注册；<br>  合作伙伴：和各个物流公司进行合作。<br>（2）管理员：<br>  管理员登录：对于已经登录的用户，若权限为管理员，可以进行管理员的登录，登陆之后才能有权限进行下一步操作；<br>  物流管理：对物流进行增删改查操作；<br>  地址管理：对物流的到达地址进行管理；<br>  用户管理：用户注册成功后，管理员可以对用户进行添加、删除操作。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目十七：项目管理平台"><a href="#项目十七：项目管理平台" class="headerlink" title="项目十七：项目管理平台"></a>项目十七：项目管理平台</h3><p><strong>介绍</strong></p><blockquote><p>在我国，某些高校或企业一直使用传统人工的方式管理文件档案，这种管理方式存在着许多缺点,如:效率低、保密性差,另外时间一长,将产生大量的文件和数据,这对于查找、更新和维护都带来了不少的困难。作为计算机应用的一部分,使用计算机对文件档案信息进行管理,具有手工管理所无法比拟的优点。所以建立项目管理系统，使管理自动化，提高信息处理的速度和准确性十分必要。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h2 id="企业管理系统"><a href="#企业管理系统" class="headerlink" title="[ 企业管理系统 ]"></a>[ 企业管理系统 ]</h2><hr><h3 id="项目一：CRM客户管理系统"><a href="#项目一：CRM客户管理系统" class="headerlink" title="项目一：CRM客户管理系统"></a>项目一：CRM客户管理系统</h3><p><strong>介绍</strong></p><blockquote><p>基本功能包括客户管理，角色管理以及产品管理。</p><p>（1）客户管理</p><p>​     客户的增加，修改，删除以及查询</p><p>（2）角色管理</p><p>角色的新增和修改。</p><p>（3）产品管理</p><p>​     产品的增加，修改，删除以及查询</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Spring + Struts2 + Hibernate + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目二：企业合同管理系统"><a href="#项目二：企业合同管理系统" class="headerlink" title="项目二：企业合同管理系统"></a>项目二：企业合同管理系统</h3><p><strong>介绍</strong></p><blockquote><p>JAVA_JSP企业合同管理系统主要用于实现企业合同的管理，<br>基本功能包括：修改个人密码、合同信息管理、收款提醒模块、安全退出系统等。本系统结构如下：<br>（1）修改个人密码模块：<br>  修改个人密码：实现修改个人密码功能；<br>（2）合同信息管理模块：<br>  合同信息管理：实现合同信息的展示、删除、添加功能；<br>  合同信息录入：实现合同信息的添加功能；<br>  合同信息查询：实现合同信息的查询功能；<br>（3）收款提醒模块：<br>  添加收款提醒： 实现收款提醒的添加功能；<br>  添加收款管理： 实现收款提醒的展示、删除功能；</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>未知</li></ul><hr><h3 id="项目三：企业电子投票系统"><a href="#项目三：企业电子投票系统" class="headerlink" title="项目三：企业电子投票系统"></a>项目三：企业电子投票系统</h3><p><strong>介绍</strong></p><blockquote><p>javaEE健康管理系统主要功能包括：投票、查看投票结果、隐藏/公布投票结果、编辑投票主题等等。本系统结构如下：<br>1.普通用户模块：<br>  1).实现登录功能<br>  2).实现用户登录的退出<br>  3).用户可以对已经开放的主题投票<br>  4).用户可以查看所有已公布了结果的主题的投票结果<br>2.管理员模块：<br>  1).实现登录功能<br>  2).实现用户登录的退出<br>  3).在后台撤销/恢复某个主题，被撤销的主题在前台不可见<br>  4).永久删除某个主题<br>  5).公布/隐藏某主题的投票结果<br>  6).编辑投票主题<br>  7).发布新主题<br>  8).新增/删除用户</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>未知</li></ul><hr><h3 id="项目四：企业快信系统"><a href="#项目四：企业快信系统" class="headerlink" title="项目四：企业快信系统"></a>项目四：企业快信系统</h3><p><strong>介绍</strong></p><blockquote><p>javaEE健康管理系统主要功能包括：投票、查看投票结果、隐藏/公布投票结果、编辑投票主题等等。本系统结构如下：<br>1.普通用户模块：<br>  1).实现登录功能<br>  2).实现用户登录的退出<br>  3).用户可以对已经开放的主题投票<br>  4).用户可以查看所有已公布了结果的主题的投票结果<br>2.管理员模块：<br>  1).实现登录功能<br>  2).实现用户登录的退出<br>  3).在后台撤销/恢复某个主题，被撤销的主题在前台不可见<br>  4).永久删除某个主题<br>  5).公布/隐藏某主题的投票结果<br>  6).编辑投票主题<br>  7).发布新主题<br>  8).新增/删除用户</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Struts2 + JDBC + JSP</li><li><strong>开发工具：</strong>未知</li></ul><hr><h3 id="项目五：固定资产管理系统"><a href="#项目五：固定资产管理系统" class="headerlink" title="项目五：固定资产管理系统"></a>项目五：固定资产管理系统</h3><p><strong>介绍</strong></p><blockquote><p>187固定资产管理系统是对高校固定资产的一个信息化管理系统，基本功能包括：对固定资产的购进、接触、销毁，对物品的使用状态、借出状态、库存状态等进行标识，对各类物品进行编号，根据编号进行查询，根据名称进行查询等。本系统结构如下：<br>（1）系统登录：<br>  用户登录模块：登录功能<br>（2）系统用户管理：<br>  对系统用户的增加<br>  系统用户的权限修改<br>  系统用户的删除<br>  分配系统用户的权限<br>  修改本身登录密码<br>  资产的相关维护<br>（3）员工信息管理：<br>  教工的增加、修改、删除、查询<br>（4）资产入库管理：<br>  资产的录入<br>  资产的属性修改<br>  资产的报废删除<br>  资产的属性查询<br>（5）资产维护管理：<br>  物资的维修、维护物资的信息修改<br>（7）资产借还管理：<br>  增加借出资产<br>  查询借出资产<br>  归还已借出资产</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Spring + Struts2 + Hibernate + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目六：企业车辆管理系统"><a href="#项目六：企业车辆管理系统" class="headerlink" title="项目六：企业车辆管理系统"></a>项目六：企业车辆管理系统</h3><p><strong>介绍</strong></p><blockquote><p>通过计算机，能够直接“透视”车辆使用情况，数据计算自动完成，尽量减少人工干预，可以使用车信息更加规范化、透明化。因此，开发一套高效率，无差错的企业车辆管理系统软件十分必要，因此设计了这个企业车辆管理系统。本系统结构如下：<br>(1) 系统管理模块：<br>  在该模块中定义了管理员信息的管理，其功能包括管理员信息添加、查询、删除等操作。<br>(2) 车辆信息管理模块：<br>  在该模块中定义了对车辆信息的管理，其功能包括车辆信息的添加、查询、修改、删除等操作。<br>(3) 驾驶员信息管理模块：<br>  在该模块中定义了对驾驶员信息的管理，其功能包括驾驶员信息的添加、查询、修改、删除等操作。<br>(4) 出车信息管理模块：<br>  在该模块中定义了对出车情况的管理，其功能包括出车情况的添加、查询、修改、删除等操作。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Spring + Struts2 + Hibernate + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目七：企业员工信息管理系统"><a href="#项目七：企业员工信息管理系统" class="headerlink" title="项目七：企业员工信息管理系统"></a>项目七：企业员工信息管理系统</h3><p><strong>介绍</strong></p><blockquote><p>企业员工信息管理系统主要用于实现公司的员工相关信息管理，基本功能包括：密码修改、员工管理、部门管理、出勤管理、工资管理、请假审核、我的请假、我的工资等。本系统结构如下：<br>（1）管理员端<br>  密码修改：修改自己的密码。<br>  员工管理：对员工的基本信息进行管理,包括查询、删除、录入。<br>  部门管理：包括添加部门以及添加子部门，删除部门等操作，便于及时更新部门信息。<br>  出勤管理：用于对员工的出勤月份以及天数进行管理，便于计算员工的工资等。<br>  工资管理：用于对员工的每个月的工资进行管理，便于对员工的工资进行管理。<br>  请假审核：用于管理员对员工的请假进行审核并加以回复，便于对员工的请假进行管理。<br>（2）员工端<br>  密码修改：修改自己的密码。<br>  我的请假：查看请假记录和发起请假申请。<br>  我的工资：查看员工自己的工资记录。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Spring + Struts2 + Hibernate + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目八：售后服务管理系统"><a href="#项目八：售后服务管理系统" class="headerlink" title="项目八：售后服务管理系统"></a>项目八：售后服务管理系统</h3><p><strong>介绍</strong></p><blockquote><p>本系统的主要任务是为基于JavaEE技术和SQL Server数据库的售后服务管理系统建立一个企业设计。主要技术要求包括:掌握web开发所需的技术,包括HTML和JSP动态网页编程技术,SQL Server数据库知识,等等。主要实现企业售后服务信息的增删改查,顾客信息的增删改查,顾客留言信息的及时反馈保存,管理员帐号增删、登录等。该系统还可以方便制造商跟踪产品的质量和服务和管理以及购买者对企业的建议提交。</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h2 id="电子政务"><a href="#电子政务" class="headerlink" title="[ 电子政务 ]"></a>[ 电子政务 ]</h2><hr><h3 id="项目一：土地档案管理系统"><a href="#项目一：土地档案管理系统" class="headerlink" title="项目一：土地档案管理系统"></a>项目一：土地档案管理系统</h3><p><strong>介绍</strong></p><blockquote><p>土地档案管理系统主要包含功能：</p><p>（1）用户管理</p><p>​     用户登陆与注册</p><p>（2）土地档案管理</p><p>​     土地档案的新增，删除，修改以及查询</p></blockquote><ul><li><strong>数据库：</strong>Oracle</li><li><strong>使用技术：</strong>Spring + Struts2 + Hibernate + JSP</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目二：电子政务网"><a href="#项目二：电子政务网" class="headerlink" title="项目二：电子政务网"></a>项目二：电子政务网</h3><p><strong>介绍</strong></p><blockquote><p>JAVA、JSP电子政务网主要用于实现政府机关的政务管理，基本功能包括：前台管网展示、留言板、后台登陆、修改密码、网站公告、政府网站、领导信箱、表格下载、政务公开、便民电话、新闻动态、地区概况、留言管理等。本系统结构如下：</p><p>（1）电子政务网(前台):<br>  领导信箱模块：实现发送邮件信息功能；<br>  地区概况模块：实现地区概况查看功能；<br>  动态信息模块：实现公告公示功能；<br>  政务信息动态模块：实现政务信息动态查看功能；<br>  法律法规模块：实现法律法规查看功能；<br>  网上办事模块：实现办事指南，意见反馈，表格下载功能；<br>  政务公开模块：实现干部任免，政府文件，政府采购功能;<br>  便民服务模块：实现便民电话，投诉举报功能;<br>  政府部门网站模块：实现政府部门网站查看功能;<br>（2）电子政务网(后台):<br>  修改密码模块: 实现密码修改功能;<br>  网站公告模块: 实现公告查看、添加、删除功能；<br>  政府网站模块：实现网站查看、添加、删除功能；<br>  领导信箱模块：实现领导信箱查看、添加、删除功能；<br>  表格下载模块：实现表格下载查看、添加、删除功能；<br>  政务公开模块：实现政务公开查看、添加、删除功能；<br>  便民电话模块：实现电话查看、添加、删除功能；<br>  新闻动态模块：实现新闻查看、添加、删除功能；<br>  地区概况模块：实现地区概况修改功能；<br>  留言管理模块：实现新闻查看、删除功能；</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Struts2 + JDBC + JSP</li><li><strong>开发工具：</strong>未知</li></ul><hr><h3 id="项目三：户籍管理系统"><a href="#项目三：户籍管理系统" class="headerlink" title="项目三：户籍管理系统"></a>项目三：户籍管理系统</h3><p><strong>介绍</strong></p><blockquote><p>户籍管理管理系统设计主要涵盖两方面的意义：户籍方面，系统上线可以给户籍在管理上带来方便，可以及时了解户籍的状况，有无迁入迁出户籍情况，缴费，欠缴等情况统计，极大的提高了员工的工作效率及准确性；用户方面：可以与户籍管理处交流，可以及时了解户籍的最新动态，户籍的通知以及其他的一些相关申请，方便了查询，节省了时间。</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>Eclipse</li></ul><p>（该项目服务器不是<code>tomcat</code>而是<code>WebLogic</code>）</p><hr><h2 id="Java基础项目"><a href="#Java基础项目" class="headerlink" title="[ Java基础项目 ]"></a>[ Java基础项目 ]</h2><hr><h3 id="项目一：Java聊天室"><a href="#项目一：Java聊天室" class="headerlink" title="项目一：Java聊天室"></a>项目一：Java聊天室</h3><p><strong>介绍</strong></p><blockquote><p>Java聊天室系统主要用于实现在线聊天，基本功能包括：服务端和客户端。本系统结构如下：<br>（1）服务端：<br>  1、能够开启和关闭服务器<br>  2、等待着客户端从特殊端口发送的请求<br>  3、监听的端口并不是固定的，服务端的端口是能够自定义的<br>  4、能够广播消息向所有连接到服务器的用户<br>（2）客户端：<br>  1、能够和服务端进行连接<br>  2、新的用户能够注册账号<br>  3、通过用户名以及密码完成用户的登陆，连接到聊天室<br>  4、用户能够在聊天室发送消息</p></blockquote><ul><li><strong>数据库：</strong>无</li><li><strong>使用技术：</strong>Java Socket</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目二：Java扫雷游戏"><a href="#项目二：Java扫雷游戏" class="headerlink" title="项目二：Java扫雷游戏"></a>项目二：Java扫雷游戏</h3><p><strong>介绍</strong></p><blockquote><p>简单玩法介绍：<br>当玩家点开第一个格子时雷区开始布雷同时计时开始。然后会在该格子上显示周围8个格子的雷数（如果没有雷则自动点开周围的格子），玩家就需要通过这些数字来判断雷的位置，将是雷的格子标记为小红旗。若玩家认为已标记的格子时错误的，可以再次右击该格子来取消标记。当某一格子被标记时，对于该格子的单击操作是无效的（防止玩家误点击导致游戏失败）。如果玩家将某一格周围8个格子中的雷标记了出来，双击该格子会自动将周围的格子点击一遍，这样可以简化玩家的操作。当玩家将全部的地雷标记出来并且其他的格子点开时，游戏结束。但是如果玩家不小心点到了地雷就会游戏失败，系统自动显示出所有的地雷。如果玩家标识的地雷数量超过了该难度下规定的雷数，计数区会以负数显示超出的雷数并且游戏不会结束。</p></blockquote><ul><li><strong>数据库：</strong>无</li><li><strong>使用技术：</strong>Java Swing</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目三：俄罗斯方块"><a href="#项目三：俄罗斯方块" class="headerlink" title="项目三：俄罗斯方块"></a>项目三：俄罗斯方块</h3><p><strong>介绍</strong></p><blockquote><p>俄罗斯方块项目，基本功能包括：游戏主界面显示模块、方块及数据显示模块、方块移动控制模块、游戏界面颜色控制模块、游戏进度、等级控制模块等。本项目结构如下：<br>（1）游戏主界面显示模块：<br>  显示游戏和帮助两个菜单；<br>  游戏使用功能键盘，得分 等级；<br>（2）画布、方块显示模块：<br>  可以根据自己的需求来自己动手更改背景图片，在方块下落过程中，根据颜色的变化识别下落的方块。<br>（3）背景画布模块设计：<br>  游戏用继承自JPanel的GameCanvas类控制背景画布的显示，用rows代表画布的行数，cols代表画布的列数，行数和列数决定着画布拥有方格的数目；<br>（4）方块移动、旋转模块<br>  通过更改横坐标或纵坐标，然后重新绘制方块实现方块移动、旋转</p></blockquote><ul><li><strong>数据库：</strong>无</li><li><strong>使用技术：</strong>Java Swing</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目四：Java即时通讯软件"><a href="#项目四：Java即时通讯软件" class="headerlink" title="项目四：Java即时通讯软件"></a>项目四：Java即时通讯软件</h3><p><strong>介绍</strong></p><blockquote><p>关于java博网即时通讯软件的设计与实现<br>Server方面：<br>  1 运行监控，打开Server,执行对其它用户的监控。<br>  2 关闭监控，关闭Server,不在对其它用户进行监控。<br>  3 阅览用户信息，阅览已登录用户信息。<br>  4 管理用户，强制使被选择的用户退出登录状态。<br>Client方面：<br>  1 申请账号功能，使用者有权限在启动客户端后进行注册以及登录。<br>  2 添加好友功能，用户将陌生人加为好友。<br>  3 删除好友功能，用户有权限可以删除好友。<br>  4 修改个人资料功能，用户有权限可以修改以往设置的所有基本信息。<br>  5 修改头像功能，用户有权限能够修改自己现在的头像。<br>  6 即时聊天功能，用户之间有权限与拥有账号的用户进行即时的聊天。<br>  7 查看聊天记录功能，用户有权限查看与好友过往的聊天记录。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Java Swing + Java Socket</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目五：出租车计价器"><a href="#项目五：出租车计价器" class="headerlink" title="项目五：出租车计价器"></a>项目五：出租车计价器</h3><p><strong>介绍</strong></p><blockquote><p>关于java出租车计价器设计与实现<br>（1）出租车计价系统可以实现出租车信息的管理。<br>  1.1出租车信息的查询：通过数据库查询出租车的车型，车号，以及是否可用<br>  1.2出租车信息的增加：向数据库中添加出租车的车型，车号，以及是否可用<br>  1.3出租车信息的修改：对数据库中已经存在的出租车的车型，车号，以及是否可用的信息进行修改<br>  1.4出租车信息的删除：删除数据库中已经存储的出租车的信息<br>（2）出租车计价系统可以实现司机信息的管理。<br>  2.1司机信息的查询：通过数据库查询出司机的年龄，性别，学历，名字等信息<br>  2.2司机信息的增加：向数据库中添加司机的年龄，性别，学历，名字等信息<br>  2.3司机信息的修改：对数据库中已经存在的司机的年龄，性别，学历，名字等信息进行修改<br>  2.4司机信息的删除：删除数据库中已经存储的司机的信息<br>（3）出租车计价系统可以实现出租车计价功能。<br>  3.1通过java多线程，模拟出租车在路上的情景<br>  3.2通过距离计费的方式，将订单的时间，乘客的信息，订单的价格等插入数据库中<br>（4）出租车计价系统可以实现订单信息的维护<br>  4.1订单信息的查询：通过数据库查询出订单的时间，价格等信息<br>  4.2订单信息的删除：删除数据库中已经存储的订单信息<br>  4.3订单信息的修改：对数据库中已经存在的订单的时间，价格等信息进行修改</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Java Swing</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目六：QQ屏幕截图工具"><a href="#项目六：QQ屏幕截图工具" class="headerlink" title="项目六：QQ屏幕截图工具"></a>项目六：QQ屏幕截图工具</h3><p><strong>介绍</strong></p><blockquote><p>基于java的QQ截屏工具的设计和实现能够实现对屏幕的随机截取，复制，保存以及添加文字等操作，便于用户对数据的处理。<br>  （1）随机获取屏幕指定区域；<br>  （2）编辑（添加文字）截图；<br>  （3）存储截图；</p></blockquote><ul><li><strong>数据库：</strong>无</li><li><strong>使用技术：</strong>Java Swing</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目七：马里奥游戏"><a href="#项目七：马里奥游戏" class="headerlink" title="项目七：马里奥游戏"></a>项目七：马里奥游戏</h3><p><strong>介绍</strong></p><blockquote><p>超级玛丽小游戏的JAVA程序，进入游戏后首先按空格键开始，利用方向键来控制的马里奥的移动，同时检测马里奥与场景中的障碍物和敌人的碰撞，并判断马里奥的可移动性和马里奥的生命值。当马里奥通过最后一个场景后游戏结束。<br>  （1）马里奥<br>  （2）障碍物<br>  （3）敌人</p></blockquote><ul><li><strong>数据库：</strong>无</li><li><strong>使用技术：</strong>Java Swing</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目八：飞机大战游戏"><a href="#项目八：飞机大战游戏" class="headerlink" title="项目八：飞机大战游戏"></a>项目八：飞机大战游戏</h3><p><strong>介绍</strong></p><blockquote><p>基于Java的飞机大战游戏主要需要我方飞机和敌方飞机，还有子弹，特殊nPC，开始背景，结束背景，以及背景音乐。我方飞机可以随意移动，敌方飞机无规律出现。游戏玩家通过鼠标移动控制飞机移动，我方飞机在游戏开始时就一直能发射子弹，当我方子弹碰到敌方飞机时，敌方飞机消失。当玩家飞机碰到敌方子弹时，生命值减一，直到玩家飞机生命值为一时，游戏结束。基本模块包括：游戏状态控制功能模块、游戏难度的调整模块、游戏界面绘画功能模块、玩家游戏控制功能模块等。本系统结构如下：<br>  （1）游戏状态控制功能模块:游戏的状态控制包括运行及结束游戏，首先进入游戏的开始页面，在游戏进行时，玩家必须躲避或者击落敌方飞机，玩家飞机的生命值降低为0的时候游 戏就会结束，弹出游戏结束界面<br>  （2）游戏难度的调整模块:玩家玩的时间越长游戏的难度越高，敌方飞机的数量越多、敌方飞机出现的频率越高，玩家保证飞机的存活的难度越高，操作难度相应也高。<br>  （3）游戏界面绘画功能模块:左上角会显示玩家飞机当前生命值，游戏时间，当前分数，其他地方用来输出玩家对我方飞机的控制与敌方飞机的动作显示<br>  （4）玩家游戏控制功能模块: 玩家可以通过控制鼠标或者键盘来控制方飞机（Hero airplane）的移动。</p></blockquote><ul><li><strong>数据库：</strong>无</li><li><strong>使用技术：</strong>Java Swing</li><li><strong>开发工具：</strong>IntelliJ IDEA</li></ul><hr><h3 id="项目九：愤怒的小鸟游戏"><a href="#项目九：愤怒的小鸟游戏" class="headerlink" title="项目九：愤怒的小鸟游戏"></a>项目九：愤怒的小鸟游戏</h3><p><strong>介绍</strong></p><blockquote><p>基于Java的愤怒的小鸟游戏的设计与实现，基本功能包括：新游戏、载入游戏、控制帮助、退出游戏等。本系统结构如下：<br>（1）新游戏：<br>  需要输入你的昵称；<br>  选择难度：容易、中等、困难、噩梦(每个级别都有5个关卡)<br>（2）载入游戏：<br>  选择你的角色；(会保留你之前的成绩)<br>  选择难度；<br>（3）控制帮助：<br>  抛出小鸟 鼠标控制弧线<br>  扔出鸟蛋 空格<br>  停止飞行 s键<br>  退出游戏 esc键</p></blockquote><ul><li><strong>数据库：</strong>无</li><li><strong>使用技术：</strong>Java Swing</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目十：雷电游戏（飞机大战）"><a href="#项目十：雷电游戏（飞机大战）" class="headerlink" title="项目十：雷电游戏（飞机大战）"></a>项目十：雷电游戏（飞机大战）</h3><p><strong>介绍</strong></p><blockquote><p>基于java的雷电游戏基本功能包括：敌方飞机随机飞行、我方飞机手动控制飞行，射击比拼，游戏闯关等。本系统结构如下：<br>（1）雷电游戏状态调整功能：<br>  在游戏启动时，游戏会自动进行初始化的验证。<br>  若初始化成功后，界面会自动进行跳转，跳转到游戏开始界面。<br>  有开始、暂停、恢复游戏等选项。<br>（2）雷电游戏难度的升级：<br>  当进入游戏后，随着时间越来越长，游戏难度会越来越大。<br>  界面中敌机增多，对飞机造成伤害的子弹增多，游戏难度增加。<br>  最后会遇到一个血条较长的怪兽，攻击其至血条为0时，自动过关跳转到下一关卡。<br>（3）玩家对飞机的控制功能：<br>玩家可以对飞机进行操控，通过前后左右键来控制飞机的飞行路线。</p></blockquote><ul><li><strong>数据库：</strong>无</li><li><strong>使用技术：</strong>Java Swing</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目十一：连连看游戏"><a href="#项目十一：连连看游戏" class="headerlink" title="项目十一：连连看游戏"></a>项目十一：连连看游戏</h3><p><strong>介绍</strong></p><blockquote><p>基于java的连连看游戏设计和实现，基本功能包括：消除模块，重新开始模块，刷新模块，选择难度模块，计时模块。本系统结构如下：<br>（1）消除模块：<br>  完成连连看游戏消除动作的模块。<br>（2）重新开始模块：<br>  完成连连看游戏中重新开始新一局游戏功能的模块。<br>（3）刷新模块：<br>  完成连连看游戏中，将游戏中未消除的图片个数记录并重新随机放置等数量图片的功能模块。<br>（4）选择难度模块：<br>  完成游戏中切换游戏难度并开始新一局游戏的模块。<br>（5）计时模块：<br>  完成游戏中倒计时并显示提示信息的模块。<br>（6）状态显示模块：<br>  完成游戏中对游戏得分、闯关数记录的模块。</p></blockquote><ul><li><strong>数据库：</strong>无</li><li><strong>使用技术：</strong>Java Swing</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目十二：模拟写字板"><a href="#项目十二：模拟写字板" class="headerlink" title="项目十二：模拟写字板"></a>项目十二：模拟写字板</h3><p><strong>介绍</strong></p><blockquote><p>此系统是使用Java语言实现简易写字板程序，能够进行输入文字操作，并具有新建文件，打开文件，保存文件，退出，复制，粘贴，剪切，全选，撤销等多种基本功能。本系统结构如下：<br>（1）菜单栏：<br>  文件模块:要用于操作整个存储或未保存的文档,包括新建，打开，保存，另存为等功能；<br>  编辑模块:编辑模块是对文本内容的基本编辑，包括剪切，复制，粘贴，删除等功能；<br>  格式模块:用于对用户输入内容显示上的操作,包括换行,字体的相关设置等功能；<br>  帮助模块:帮助菜单是用来展示于写字板有关的一些信息；<br>（2）文本区域：<br>  文本区域主要用来承载用户输入的主要内容；</p></blockquote><ul><li><strong>数据库：</strong>无</li><li><strong>使用技术：</strong>Java Swing</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目十三：推箱子游戏"><a href="#项目十三：推箱子游戏" class="headerlink" title="项目十三：推箱子游戏"></a>项目十三：推箱子游戏</h3><p><strong>介绍</strong></p><blockquote><p>基于JAVA的推箱子游戏系统主要用于实现游戏推箱子功能，提供多种不同难度的关卡。本系统结构如下：<br>（1）初始化模块: 该模块包括屏幕初始化和游戏第一关的初始化。屏幕初始化用于输出欢迎信息和操<br>（2）画图模块: 该模块主要是被其它模块调用，用于画墙、在空地画箱子、在目的地画箱子、画小人和画目的地。<br>（3）移动箱子模块: 该模块用于移动箱子，包括目的地之间、空地之间和目的地与空地之间的箱子移动。<br>（4）移动小人模块: 该模块用于控制小人移动，从而推动箱子到目的地。<br>（5）功能控制模块: 该模块是几个功能函数的集合，包括屏幕输出功能、指定位置状态判断功能和关卡重置功能。</p></blockquote><ul><li><strong>数据库：</strong>无</li><li><strong>使用技术：</strong>Java Swing</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目十四：坦克大战游戏"><a href="#项目十四：坦克大战游戏" class="headerlink" title="项目十四：坦克大战游戏"></a>项目十四：坦克大战游戏</h3><p><strong>介绍</strong></p><blockquote><p>此系统是使用Java语言实现坦克大战游戏程序，玩家通过连接访问进入游戏，通过操纵坦克来守卫基地，玩家还可以获得超级武器来提升坦克的属性，摧毁全部敌方坦克来取得胜利。本系统结构如下：<br>（1）面板功能：<br>  对双方坦克、基地、河道、草坪、普通墙与铁墙等地图元素,还实现了页面按钮功能，玩家可以点击按钮来实现相应的功能。<br>（2）坦克功能：<br>  操作玩家坦克的方法，还设置了超级武器，玩家吃掉后会获得特殊技能。<br>（3）子弹功能：<br>  设置了子弹打中不同物体对象产生的不同效果。</p></blockquote><ul><li><strong>数据库：</strong>无</li><li><strong>使用技术：</strong>Java Swing</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h2 id="ERP（进销存）系统"><a href="#ERP（进销存）系统" class="headerlink" title="[ ERP（进销存）系统 ]"></a>[ ERP（进销存）系统 ]</h2><hr><h3 id="项目一：百货中心供应链管理系统"><a href="#项目一：百货中心供应链管理系统" class="headerlink" title="项目一：百货中心供应链管理系统"></a>项目一：百货中心供应链管理系统</h3><p><strong>介绍</strong></p><blockquote><p>百货中心供应链管理系统主要用于实现了企业管理数据统计等。本系统结构如下：<br>（1）管理界面：<br>  登录模块：实现管理员登录功能；<br>  合作公司管理模块：实现合作公司信息的增加、修改、查看功能；<br>  采购管理模块：实现采购的增加、修改、查看功能；<br>  数据统计模块：实现数据的统计分析功能；</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Spring + Struts2 + Hibernate + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目二：采购管理系统"><a href="#项目二：采购管理系统" class="headerlink" title="项目二：采购管理系统"></a>项目二：采购管理系统</h3><p><strong>介绍</strong></p><blockquote><p>本系统是一个独立的系统，用来解决企业采购信息的管理问题。采用JSP技术构建了一个有效而且实用的企业采购信息管理平台，目的是为高效地完成对企业采购信息的管理。经过对课题的深入分析，采购系统需实现以下功能模块：<br>1.用户登录<br>  对用户输入的用户名和密码进行匹配，只有合法的用户可以登录成功，进入主界面，进行操作。是系统安全性的第一层保护层。不同角色的用户登录（比如普通用户和超级管理员）的操作页面不一样。<br>2.供应商管理<br>  灵活管理供货商，及时添加及修改供货商信息，为采购计划的制定提供保障。<br>3.材料管理<br>  对材料进行管理，管理材料种类及库存，及时了解材料的库存信息，有助于做出正确的采购选择。<br>4.订单管理<br>  系统设计了多种订单。不同权限的操作员只能对其拥有权限操作的订单进行操作。<br>5.信息查询<br>  根据关键字快速检索信息。</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Struts2 + Hibernate + JSP</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目三：仓库管理系统"><a href="#项目三：仓库管理系统" class="headerlink" title="项目三：仓库管理系统"></a>项目三：仓库管理系统</h3><p><strong>介绍</strong></p><blockquote><p>基于WEB的仓库管理系统主要用于实现仓库的出入库管理，基本功能包括：入库模块、出库模块、商品查看模块、用户注册模块、个人信息管理模块等。本系统结构如下：<br>  入库模块：入库新商品，或者是入库已有商品。<br>  出库模块：对已经入库的商品进行出库操作。<br>  商品查看模块：查看目前的库存商品信息。<br>  用户注册模块：进行帐号密码的注册，包括用户其他信息。<br>  个人信息管理模块：查看或者修个个人信息。</p></blockquote><ul><li><strong>数据库：</strong>Oracle</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目四：进销存管理系统"><a href="#项目四：进销存管理系统" class="headerlink" title="项目四：进销存管理系统"></a>项目四：进销存管理系统</h3><p><strong>介绍</strong></p><blockquote><p>进销存管理系统，实现对企业运作过程中的进货、销售、仓储的电子化操作，可以节省大量人力物力，可以说对企业的运作带来不可限量的好处。实现一个简单实用，操作界面友好的进销存管理系统是首要解决的任务。然后一是要实现对库存数据进行分析，对接下来的进货进行一些指导；二是实现对销售数据的采集分析，对企业决策者对下一个季度或者年份的销售计划提供一个参考的功能。系统肯定要具备对进销存的一些基本的增删改查操作。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Spring Boot（Spring + Spring MVC） + Spring Data JPA + JSP</li><li><strong>开发工具：</strong>Spring tool suit（STS）其实就是装了插件的Eclipse</li></ul><hr><h3 id="项目五：企业财务管理系统"><a href="#项目五：企业财务管理系统" class="headerlink" title="项目五：企业财务管理系统"></a>项目五：企业财务管理系统</h3><p><strong>介绍</strong></p><blockquote><p>企业财务管理系统主要用于实现公司的财务管理，基本功能包括：系统登录、部门信息管理、员工信息管理、资产、经营、费用信息管理等。本系统结构如下：<br>（1）职工端：<br>  登录模块：登录功能；<br>  个人信息模块：可修改个人的信息；<br>  个人工资模块：可查阅自己的工资；<br>  公司资产模块：可查看公司的资产信息；<br>  公司经营模块：可查看公司的经营信息；<br>  公司费用模块：可查看公司的费用信息；<br>  年终资产模块：可查看公司的总资产信息；<br>（2）超级管理员端：<br>  登录模块：实现管理员登录功能；<br>  个人信息模块：可修改个人的信息；<br>  部门信息管理模块：实现部门的增加、修改、删除、查看功能；<br>  职工信息管理模块：实现职工信息的增加、修改、删除、查看功能；<br>  职工工资管理模块：实现职工工资的增加、修改、查看功能；<br>  资产类别管理模块：实现资产类别的增加、删除、查看功能；<br>  资产信息管理模块：实现资产信息的增加、查看功能；<br>  经营信息管理模块：实现经营信息的增加、查看功能；<br>  费用信息管理模块：实现费用信息的增加、查看功能；<br>  年终资产分析模块：实现公司总资产的查看功能；</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Struts + Hibernate + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目六：商品供应管理系统"><a href="#项目六：商品供应管理系统" class="headerlink" title="项目六：商品供应管理系统"></a>项目六：商品供应管理系统</h3><p><strong>介绍</strong></p><blockquote><p>本系统是一个独立的系统，用来解决企业采购信息的管理问题。采用JSP技术构建了一个有效而且实用的企业采购信息管理平台，目的是为高效地完成对企业采购信息的管理。经过对课题的深入分析，采购系统需实现以下功能模块：<br>各个模块实现的功能如下：<br>1.用户登录<br>  对用户输入的用户名和密码进行匹配，只有合法的用户可以登录成功，进入主界面，进行操作。是系统安全性的第一层保护层。不同角色的用户登录（比如普通用户和超级管理员）的操作页面不一样。<br>2.供应商管理<br>  灵活管理供货商，及时添加及修改供货商信息，为采购计划的制定提供保障。<br>3.材料管理<br>  对材料进行管理，管理材料种类及库存，及时了解材料的库存信息，有助于做出正确的采购选择。<br>4.订单管理<br>  系统设计了多种订单。不同权限的操作员只能对其拥有权限操作的订单进行操作。<br>5.信息查询<br>  根据关键字快速检索信息。</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Struts + Hibernate + JSP</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目七：工厂进销存管理系统"><a href="#项目七：工厂进销存管理系统" class="headerlink" title="项目七：工厂进销存管理系统"></a>项目七：工厂进销存管理系统</h3><p><strong>介绍</strong></p><blockquote><p>本XXX陶瓷工厂的进销存管理系统是基于eclipse开发环境，前台采用的是Swing 和 AWT 相关组件进行的GUI设计，后台使用的是SQL Server数据库。且该XXX陶瓷工厂的进销存管理系统共分为六大模块，分别为<br>1.基础信息管理模块<br>客户，原料商品，供应商，产品信息的管理和维护<br>2.进货模块<br>  原料商品的进货和退货<br>3.销售模块<br>  产品的销售和销售退货<br>4.查询统计模块<br>  负责查询一些基础信息<br>5.库存管理模块<br>  原料商品的出库，产品的入库，库存盘点和价格修改<br>6.系统管理模块<br>  操作员管理和密码修改</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Java Swing</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目八：物资管理系统"><a href="#项目八：物资管理系统" class="headerlink" title="项目八：物资管理系统"></a>项目八：物资管理系统</h3><p><strong>介绍</strong></p><blockquote><p>恒鑫租赁站长期大量出租各型钢管、扣件、塔吊等建筑施工设备。本系统为恒鑫租赁站提供了一个方便快捷的物资管理系统，方便出租物资的管理。系统功能主要包括：<br>  用户管理，包括管理员信息查看、管理员密码修改；<br>  正常订单管理：包括新增正常订单、修改有误订单、删除错误订单；<br>  资金结算管理：费用统计；<br>  材料租赁管理：包括订单出租查询、器材回收管理、日租金管理、仓库库存管理等。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Struts2 + Hibernate + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h2 id="校园相关系统"><a href="#校园相关系统" class="headerlink" title="[ 校园相关系统 ]"></a>[ 校园相关系统 ]</h2><hr><h3 id="项目二：网络考试系统"><a href="#项目二：网络考试系统" class="headerlink" title="项目二：网络考试系统"></a>项目二：网络考试系统</h3><p><strong>介绍</strong></p><blockquote><p>网络考试系统主要用于实现高校在线考试，基本功能包括：自动组卷、试卷发布、试卷批阅、试卷成绩统计等。本系统结构如下：<br>（1）学生端：<br>  登录模块：登录功能；<br>  网络考试模块：可参加考试，并查看考试结果，提交试卷后老师允许的情况下查看错题；<br>（2）超级管理员端：<br>  登录模块：实现管理员登录功能；<br>  用户管理模块：实现用户信息的增加、修改、查看功能；<br>  角色权限管理模块：实现角色的增加、修改、查看功能；<br>  试卷管理模块：实现试卷信息的增加、修改、查看功能；<br>  试题管理模块：实现试题信息的增加、修改、查看功能；<br>（3）试题管理员端（老师）：<br>  试卷管理模块：实现试卷信息的增加、修改、查看功能；<br>  试题管理模块：实现试题信息的增加、修改、查看功能；</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h2 id="医疗项目"><a href="#医疗项目" class="headerlink" title="[ 医疗项目 ]"></a>[ 医疗项目 ]</h2><hr><h3 id="项目一：健康管理系统"><a href="#项目一：健康管理系统" class="headerlink" title="项目一：健康管理系统"></a>项目一：健康管理系统</h3><p><strong>介绍</strong></p><blockquote><p>javaEE健康管理系统主要功能包括：教师登录退出、教师饮食管理、教师健康日志、体检管理等等。本系统结构如下：<br>（1）用户模块：<br>  实现登录功能，退出，用户注册<br>（2）教师饮食管理：<br>  根据教师的相关信息，计算其每天所需热量，给出一周的推荐菜单。<br>（3）教师健康日志：<br>  用户可以记录自己健康日记，记录每一天的睡眠，饮酒，吸烟，血压，体重等情况。<br>（4）教师体检管理：<br>  教师可通过该平台查询每次的体检结果，显示部分项目随时间变化的曲线<br>（5）疾病预测评估：<br>  针对糖尿病和高血压两种疾病，利用数学线性回归的方法，模拟计算出教师患病概率。<br>(6) 后台管理员模块<br>  管理员用户登录功能：通过账号登录系统。<br>  管理员管理教师功能：可以增删改查教师基本信息。<br>  管理员管理体检结果：可以增删改查教师体检记录。<br>  健康新闻管理：可以发布或删除、编辑新闻</p></blockquote><ul><li><strong>数据库：</strong>Oracle</li><li><strong>使用技术：</strong>Spring + Struts2 + Hibernate + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目二：牙科诊所管理系统"><a href="#项目二：牙科诊所管理系统" class="headerlink" title="项目二：牙科诊所管理系统"></a>项目二：牙科诊所管理系统</h3><p><strong>介绍</strong></p><blockquote><p>为适应医疗信息管理发展的需要，开发基于B/S结构的私人牙科诊所病例管理系统。该系统应具有以下功能：</p><p>（1）登陆模块，可分为管理员登陆和普通用户医生登录三个模块。</p><p>（2）用户注册模块，对用户注册的用户名的要求，不同的用户要求要有不同的用户名。</p><p>（3）系统管理模块，包括添加管理员，管理员密码的修改。</p><p>（4）挂号管理模块，包括患者的名字、性别、年龄、现住地址和患者简介。</p><p>（5）患者管理模块，对患者进行增加、患者删除、患者信息的修改。</p><p>（6）开药管理模块，对药品的增加、删除、修改、查询，患者病历查</p><p>（7）科室管理模块，管理员可以新建，修改，删除，科室信息</p><p>（8）留言管理，管理员可以新建，修改，删除留言信息</p><p>（9）预约挂号模块，用户可以在线进行预约挂号，用户可以选择普通号和专家号。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Servlet + JDBC+ JSP</li><li><strong>开发工具：</strong>未知</li></ul><hr><h3 id="项目三：医院在线挂号系统"><a href="#项目三：医院在线挂号系统" class="headerlink" title="项目三：医院在线挂号系统"></a>项目三：医院在线挂号系统</h3><p><strong>介绍</strong></p><blockquote><p>医院挂号系统主要用于实现医院的挂号。<br>本系统结构如下：<br>（1）前台功能：<br>  用户注册：注册功能；<br>  用户登录：登录功能；<br>  医院查询：选择医院、科室查询该医院下的医生信息<br>  挂号:选择医生后点击挂号，填写信息完成挂号<br>  管理中心:点击管理中心可以修改个人信息、取消挂号<br>（2）系统管理员：<br>  登录模块：实现管理员登录功能；<br>  医院管理模块：实现医院的增加、删除功能；<br>  科室管理模块：实现科室的增加、删除功能；<br>  公告管理模块：实现公告的增加、删除功能；<br>  退出系统模块：实现用户的退出功能；</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Spring + Struts2 + Hibernate + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目四：住院管理系统"><a href="#项目四：住院管理系统" class="headerlink" title="项目四：住院管理系统"></a>项目四：住院管理系统</h3><p><strong>介绍</strong></p><blockquote><p>本系统主要分为六大模块，分别是医生管理模块、病人管理模块、病床管理模块、收费管理模块、统计分析模块和系统功能模块，医生、病人和医院的管理人员都可以通过此系统寻找出自己所需要的信息。</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Servlet + JDBC+ JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h2 id="其他细分行业项目"><a href="#其他细分行业项目" class="headerlink" title="[ 其他细分行业项目 ]"></a>[ 其他细分行业项目 ]</h2><hr><h3 id="项目一：码头船只出行管理系统"><a href="#项目一：码头船只出行管理系统" class="headerlink" title="项目一：码头船只出行管理系统"></a>项目一：码头船只出行管理系统</h3><p><strong>介绍</strong></p><blockquote><p>（1）用户登录模块：<br>  一般（查看）用户，权限只有修改个人信息和查看功能<br>  （操作）用户登录，可以修改自己的信息，还可以对系统内容进行增加、删除和修改<br>  系统管理员，可以修改自己的信息，并且不仅有查看、增删改的基本权限，还有对用户的管理和注册权限</p><p>（2）用户管理模块：<br>  该模块实现对用户的增加，删除和修改<br>（3）个人信息维护模块：<br>  该模块实现用户对自己的名字和密码等个人信息的修改<br>（4）新闻公告管理模块：<br>  该模块实现新闻公告的增加，删除和修改<br>（5）船只管理模块：<br>  该模块实现船只的增加，删除和修改<br>（6）路线管理模块：<br>  该模块实现路线的增加，删除和修改，以及船只与路线关系的管理<br>（7）货柜管理模块：<br>  该模块实现货柜的增加，删除和修改，以及船只与货柜关系的管理</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Servlet + JDBC+ JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目二：超市积分管理系统"><a href="#项目二：超市积分管理系统" class="headerlink" title="项目二：超市积分管理系统"></a>项目二：超市积分管理系统</h3><p><strong>介绍</strong></p><blockquote><p>超市会员积分管理系统主要用于实现了企业管理数据统计等。本系统结构如下：<br>（1）网络会员管理中心界面：<br>  会员修改密码信息模块：实现会员密码功能；<br>  会员登陆模块：实现会员登陆功能；<br>  会员注册模块：实现会员注册功能；<br>  留言板模块：实现留言板留言功能<br>（2）后台管理界面：<br>  系统用户管理模块：实现管理员的增加、查看功能；<br>  会员信息管理模块：实现会员信息的增加、修改、查看功能；<br>  注册用户管理模块：实现注册用户的增加、修改、查看功能；<br>  会员卡管理模块：实现会员卡信息的增加、查看功能；<br>  商品销售管理模块：实现商品信息的增加、查看功能；<br>  会员积分管理模块：实现合作公司信息的增加、查看功能；<br>  信息统计模块：实现数据统计报表功能；<br>  留言板模块：实现留言板信息的增加、修改、查看功能；</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Servlet + JDBC+ JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目三：保险业务管理系统"><a href="#项目三：保险业务管理系统" class="headerlink" title="项目三：保险业务管理系统"></a>项目三：保险业务管理系统</h3><p><strong>介绍</strong></p><blockquote><p>本系统主要是为了开发一个操作方便、使用快捷、处理高效的保险管理系统。因此，本系统是从人工操作容易产生错误、过程繁琐、工作效率不高，保密性差不足之处，对系统的可操作性、稳定性和实用性有一定的限制，并能安全地保存数据于数据库中来提高其系统的保密性。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Spring + Struts2 + Hibernate + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目四：机场航班起降与协调管理系统"><a href="#项目四：机场航班起降与协调管理系统" class="headerlink" title="项目四：机场航班起降与协调管理系统"></a>项目四：机场航班起降与协调管理系统</h3><p><strong>介绍</strong></p><blockquote><p>此次项目是一个基于Java的机场航班起降与协调系统（机场航班调度系统）。通过此系统帮助机场地面指挥人员进行更加明确的航班调度和指令发送，尽可能减少航班调度的错误率，尽可能规避航班调度错误的风险，极大程度地避免空难的发生。减少地面指挥人员指令发布的失误率，与航班建立数据上的可视的指令发布，使航班在可能的无线电干扰的情况下可以正常起降。实时管理航班信息，<br>建立地面指挥员与机长之间的指令通信。<br>地面指挥员端：<br>  1.指挥员登录<br>  2.航班信息的浏览<br>  3.航班信息的操作：航班的删除，航班的添加，航班信息的修改，航班信息的搜索<br>  4.指挥信息的操作：指挥信息的查询，指令的发布，指令的修改，指令的删除<br>机长端：<br>  1.机长登录<br>  2.航班信息的查询<br>  3.航班指挥信息的操作：航班指挥信息查询，航班请求的发布，航班请求的删除，航班请求的修改</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Servlet + JDBC+ JSP</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目五：敬老院管理系统"><a href="#项目五：敬老院管理系统" class="headerlink" title="项目五：敬老院管理系统"></a>项目五：敬老院管理系统</h3><p><strong>介绍</strong></p><blockquote><p>本系统主要是针对敬老院工作人员即管理员和员工设计的。敬老院管理系统将IT技术为养老院提供一个接口便于管理信息,存储老人个人信息和其他信息,查找和更新信息的养老院档案,节省了员工的劳动时间,大大降低了成本。其主要功能包括：<br>系统管理员用户功能介绍：<br>  用户管理员、员工登录、老人信息管理、床位分配管理、护工薪资管理、护工请假记录、老人请假记录、入住费用和事故记录管理。以及对这些功能的增、删、改、查处理<br>普通管理员用户 （护工身份）功能介绍：<br>  密码信息管理用例分析, 老人信息查看用例分析, 请假信息查看用例分析,护工薪资查看用例分析</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Servlet + JDBC+ JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目六：银行排号系统"><a href="#项目六：银行排号系统" class="headerlink" title="项目六：银行排号系统"></a>项目六：银行排号系统</h3><p><strong>介绍</strong></p><blockquote><p>（1）服务器端<br>  1）取号功能：打开服务器与终端进行通信。由于把服务器设置到了用户的一端，所以在服务器端进行取号，然后把号存到数据库中。<br>  2）统计功能：数据访问层从数据库中查出所有取票人数和等待人数在服务器端界面显示。<br>  3）删除功能：删除当前取票顾客的排号。<br>  4）查询功能：顾客可以从此处了解到所有顾客的取票情况及被处理状况。<br>  5）通知功能：从服务器端获得排号，通过服务器端通知<strong><em>用户到\</em></strong>工作台办理业务。<br>（2）客户端<br>  1） 登录功能：业务员从此处登录，业务员的姓名，密码是事先录入数据库的。<br>  2） 叫号功能：业务员点击处理按钮触发事件发送信息给服务器，服务器从数据库拿到号票，返回给业务员进行业务处理。<br>  3）统计功能：数据访问层从数据库查询总取票人数和查询未处理人数在业务端显示。<br>  4） 删除功能：业务员可以删除数据库中所有的记录，也可以选择删除某条记录。<br>  5）查询功能：业务员可以查询所有顾客的取票情况及业务员对号票的处理情况，这块主要为了能够及时掌握顾客取票信息及业务员处理情况。</p></blockquote><ul><li><strong>数据库：</strong>Oracle</li><li><strong>使用技术：</strong>Java Swing + JDBC</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目七：健身俱乐部会员系统"><a href="#项目七：健身俱乐部会员系统" class="headerlink" title="项目七：健身俱乐部会员系统"></a>项目七：健身俱乐部会员系统</h3><p><strong>介绍</strong></p><blockquote><p>健身俱乐部管理系统主要由六个模块组成。<br>1.会员管理子系统:包括会员个人信息的修改、会员的增加和删除、会员信息查询以及会员卡的管理。<br>2.预约管理子系统:包括健身预约信息的录入、和删除。<br>3.人事资料管理子系统:包括人事资料的添加、删除、修改功能。<br>4.器材管理子系统:包括器材信息的录入、增加和删除、修改、产品信息查询。<br>5.考勤、工资管理子系统:包括考勤、工资信息的录入、增加和删除、修改。<br>6.系统维护子系统:包括修改密码、修改用户名、删除管理员和增加管理员四个功能模块。<br>7.用户管理模块:管理员添加、删除、查询用户基本信息和设置用户权限。</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Servlet + Hibernate + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目八：停车场管理系统1"><a href="#项目八：停车场管理系统1" class="headerlink" title="项目八：停车场管理系统1"></a>项目八：停车场管理系统1</h3><p><strong>介绍</strong></p><blockquote><p>基于Web停车场管理系统主要用于实现停车场相关信息管理，基本功能包括：系统信息管理模块、车位信息管理模块、IC卡信息管理模块、固定车主停车管理模块、临时车辆信息管理模块、系统功能操模块等。本系统结构如下：<br>  (1)系统信息管理模块：角色的增加、删除、修改和查询；用户的增加、删除、修改和查询。<br>  (2)车位信息管理模块：车位信息的增加、删除、修改和查询。<br>  (3)IC卡信息管理模块：IC卡信息的增加、删除、修改和查询。<br>  (4)固定车主停车管理模块：对固定车主的停车信息进行增加、删除、修改和查询<br>  (5)临时车辆信息管理模块：对临时车辆的停车信息进行增加、删除、修改、查询和打印<br>  (6)系统功能操模块：退出登陆、修改密码。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Spring MVC + JDBC + JSP</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目九：停车场管理系统2"><a href="#项目九：停车场管理系统2" class="headerlink" title="项目九：停车场管理系统2"></a>项目九：停车场管理系统2</h3><p><strong>介绍</strong></p><blockquote><p>车场管理系统开发出来的目的是为了方便公共场所或者企业等单位的停车管理，管理系统的高效和经济优势巨大，现如今已经有不少的高档次场所都已经引入了这种管理方式，停车场的管理人员和使用人员无需去关注它的内部设计，只需要关注相关信息的呈现和操作，如车辆信息，车位情况，而直观的了解这些无疑可以使管理者迅速的掌握停车场的实施情况，使车辆的停留和出入管理都更加的方便快捷。</p></blockquote><ul><li><strong>数据库：</strong>SQL Server</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>Eclipse</li></ul><hr><h3 id="项目十：酒店管理系统"><a href="#项目十：酒店管理系统" class="headerlink" title="项目十：酒店管理系统"></a>项目十：酒店管理系统</h3><p><strong>介绍</strong></p><blockquote><p>按照总体设计的功能模块和需求分析，酒店管理系统的各个模块的数据字典：<br>1、系统管理员数据：包含的数据项用户名，密码。<br>2、客房类型数据：包含的数据项有id号，类型名称。<br>3、客房信息数据:包含的数据项有房间号，房间面积，房间简介，房间图片，房间类型。<br>4、房间预订数据：包含的数据项有预订客房，预订时间，预订用户的名字及电话，预订天数。<br>5、入住消费数据：包含的数据项有入住客房，入住时间，客户姓名及联系方式，预订天数和消费金额。<br>6、客户信息数据：包含的数据项有客户名字，地址，电话，E-mail。<br>7、特色餐品数据：包含的数据项有名称，描述，图片，价格。<br>8、餐桌预订数据：包含的数据项有预订时间，预订餐桌号，预订人。<br>9、餐饮消费数据：包含的数据项有消费时间，消费金额，消费者姓名。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目十一：挖掘机配件营销系统"><a href="#项目十一：挖掘机配件营销系统" class="headerlink" title="项目十一：挖掘机配件营销系统"></a>项目十一：挖掘机配件营销系统</h3><p><strong>介绍</strong></p><blockquote><p>挖掘机配件销售管理系统是根据挖掘机配件销售的过程来分析该系统，系统分为三大模块。<br>库存管理模块包括：<br>  （1）库存查看，在客户进行咨询或者需要购买的时候可以通过库存查询知道当前库存中有没有货。<br>  （2）配件信息管理，管理系统中所有的配件信息。<br>  （3）配件进货，根据实际情况，及时更新库存，扩大配件的供应量，增加库存。<br>销售管理模块包括：<br>  （1）配件销售，对配件进行销售。<br>  （2）配件退还，用户不满意或者在退换期内可以进行配件退还操作。<br>  （3）利润统计，对系统中销售的利润进行统计和查看，也可以导出EXCEL。<br>用户管理模块：<br>  （1）员工信息管理，该部分主要包含管理员和普通员工的信息。<br>  （2）客户信息录管理，该部分主要管理系统中所有的新老客户信息，方便后期进行跟踪记录和回访等。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>MyEclipse</li></ul><hr><h3 id="项目十二：银行业务绩效考核系统"><a href="#项目十二：银行业务绩效考核系统" class="headerlink" title="项目十二：银行业务绩效考核系统"></a>项目十二：银行业务绩效考核系统</h3><p><strong>介绍</strong></p><blockquote><p>业务绩效考核系统主要目的是使绩效考核信息管理清晰化，基本功能包括：权限处理模块、输入模块、处理模块、统计输出模块、维护模块等。本系统结构如下：<br>1.权限处理模块：<br>  管理员与普通柜员，管理员进入的是管理员页面，普通柜员进入普通柜员的界面。<br>2.输入模块<br>  2.1 普通柜员用户注册：普通柜员通过输入用户名（工号即用户名），名字，密码进行注册，获得进入本系统权限。<br>  2.2 柜员选择柜员身份登入：柜员进入后可以查看本人工作情况的信息。<br>  2.3 管理员界面：登入后，记录柜员工作情况：输入柜员工号，柜员名字，记录业务笔数，最后一栏并记录柜员员工加减分情况（笔数处于10的整数部分为加减分情况，以10分为上限）。除此之外，管理员还能对普通柜员的权限进行修改，删除不必要的用户。<br>  2.4 对管理员输入数据进行处理：比如工号只能为7位，开头必须是882；加分减分的值不能大于10等等。<br>3.处理模块<br>  3.1 查询：输入柜员工号，可以查询到该柜员的工作情况以及加分减分情况及薪酬情况；按日期查询，可以查询到该日期本合作银行每位柜员的工作情况及加减分情况。<br>  3.2 薪酬查询：柜员薪酬计算应计算考核薪酬除以10分为标准分值，考核实际得分乘以分值为可兑现年薪（总行班子成员18000元/季、中层正职12000元/季、中层副职9000元/季、员工6000元/季、短期合同工（三年以下）1500元/季。） 月总分/月天数/10*薪酬标准<br>  4.统计输出模块：比如可以统计本合作银行业务笔数由多到少排名，加减分情况排名。<br>  5.维护模块：对系统进行维护，定期对数据进行备份，对历史数据库进行备份，对密码口令进行维护。</p></blockquote><ul><li><strong>数据库：</strong>MySQL</li><li><strong>使用技术：</strong>Servlet + JDBC + JSP</li><li><strong>开发工具：</strong>未知</li></ul><hr><h2 id="最新毕设成品（2019-9-至今）"><a href="#最新毕设成品（2019-9-至今）" class="headerlink" title="最新毕设成品（2019.9~至今）"></a>最新毕设成品（2019.9~至今）</h2><font color="#dd0000">页面中图片加载较慢，请耐心等待</font><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/kcsj/new1.jpg" alt></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/kcsj/new2.jpg" alt></p><h2 id="团队介绍"><a href="#团队介绍" class="headerlink" title="团队介绍"></a>团队介绍</h2><p>团队成员主要由毕业大学生组成，对于学生需求更加了解，会尽量满足学生<strong>需求</strong>，帮助同学们顺利<strong>答辩</strong>。</p><p>想<strong><font color="#dd0000">加入团队</font> </strong>的请<strong><font color="#dd0000">查看下方的联系方式</font> </strong></p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><blockquote><p><strong>QQ：1755497577（备注：代写 ）</strong></p></blockquote><div align="center" width="80%"><br>  <img width="30%" src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/kcsj/qq.jpg"><br></div><blockquote><p><strong>微信（备注：代写）</strong></p></blockquote><div align="center" width="80%"><br>  <img width="30%" src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/kcsj/wechat.png"><br></div>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/kcsj/bd.webp&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="代写" scheme="https://lijinhongpassion.github.io/tags/%E4%BB%A3%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>2020年上半年计划</title>
    <link href="https://lijinhongpassion.github.io/codeant/20201.html"/>
    <id>https://lijinhongpassion.github.io/codeant/20201.html</id>
    <published>2020-06-30T05:02:43.000Z</published>
    <updated>2020-02-02T03:52:54.492Z</updated>
    
    <content type="html"><![CDATA[<hr><p><blockquote><strong>2020年上半年计划</strong></blockquote></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/20201/2020年度计划.png" alt="2020年上半年计划"></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;blockquote&gt;&lt;strong&gt;2020年上半年计划&lt;/strong&gt;&lt;/blockquote&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPa
      
    
    </summary>
    
    
      <category term="年度计划" scheme="https://lijinhongpassion.github.io/tags/%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Java-你真的懂了try{return}finally{return};吗？</title>
    <link href="https://lijinhongpassion.github.io/codeant/beee.html"/>
    <id>https://lijinhongpassion.github.io/codeant/beee.html</id>
    <published>2020-02-26T02:59:46.000Z</published>
    <updated>2020-02-26T15:01:42.400Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1580602972248-1f93dd762133?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1051&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>我们常知的<code>try catch finally</code>是捕获处理异常的，但是<code>try{return}finally{return};</code>的执行顺序是怎样的呢？<code>try{return}finally{};</code>呢？下面就来简单了解一下。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><strong>例一：try{return}finally{};</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(method1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        ++x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：1</strong></p><p><strong>例二：try{return}finally{return};</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(method1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：2</strong></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>根据jdk的官方描述，try里面遇到return的时候，先将值存储于<strong>常量池</strong>，再继续执行finally里面的代码。finally代码执行完毕后再返回<strong>常量池里的那个结果</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1580602972248-1f93dd762133?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1051&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://lijinhongpassion.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java-Java线程之守护线程&amp;用户进程</title>
    <link href="https://lijinhongpassion.github.io/codeant/25c3.html"/>
    <id>https://lijinhongpassion.github.io/codeant/25c3.html</id>
    <published>2020-02-11T09:02:19.000Z</published>
    <updated>2020-02-11T10:52:56.588Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1581405919332-d9f2f192dc6e?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) </p><p>用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：</p><p>只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。<br>Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者</p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><blockquote><p>以下内容转载至： <a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306580788183074" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1306580788183074</a> </p></blockquote><h4 id="什么是守护线程"><a href="#什么是守护线程" class="headerlink" title="什么是守护线程"></a>什么是守护线程</h4><p>Java程序入口就是由JVM启动<code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p><p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p><p>但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(LocalTime.now());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个线程不结束，JVM进程就无法结束。问题是，由谁负责结束这个线程？</p><p>然而这类线程经常没有负责人来负责结束它们。但是，当其他线程结束时，JVM进程又必须要结束，怎么办？</p><p>答案是使用守护线程（Daemon Thread）。</p><p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p><p>因此，JVM退出时，不必关心守护线程是否已结束。</p><hr><h4 id="创建守护线程"><a href="#创建守护线程" class="headerlink" title="创建守护线程"></a>创建守护线程</h4><p>如何创建守护线程呢？方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p><hr><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p> (1) thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把      正在运行的常规线程设置为守护线程。<br>(2) 在Daemon线程中产生的新线程也是Daemon的。<br>(3) 不要认为所有的应用都可以分配给Daemon来进行服务，比如读写操作或者计算逻辑。 </p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>守护线程是为其他线程服务的线程；</p><p>所有非守护线程都执行完毕后，虚拟机退出；</p><p>守护线程不能持有需要关闭的资源（如打开文件等）。</p><hr><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><ul><li>定义：守护线程–也称“服务线程”，在没有用户线程可服务时会自动离开。</li><li>优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。</li><li>设置：通过setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在线程对象创建之前 用线程对象的setDaemon方法。</li><li>example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</li><li>生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。那Java的守护线程是什么样子的呢。当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则JVM不会退出。 </li></ul><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/25c3/1.png" alt="Hotspot JVM 后台运行的主要系统线程"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>参考文章中含有例子，可参考。</p><p><a href="https://blog.csdn.net/shimiso/article/details/8964414" target="_blank" rel="noopener">Java中守护线程的总结</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306580788183074" target="_blank" rel="noopener">廖雪峰 – 守护线程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1581405919332-d9f2f192dc6e?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1050&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://lijinhongpassion.github.io/categories/java/"/>
    
    
      <category term="Java" scheme="https://lijinhongpassion.github.io/tags/Java/"/>
    
      <category term="thread" scheme="https://lijinhongpassion.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>Redis-redis为什么是单线程</title>
    <link href="https://lijinhongpassion.github.io/codeant/redis1.html"/>
    <id>https://lijinhongpassion.github.io/codeant/redis1.html</id>
    <published>2020-02-11T06:35:49.000Z</published>
    <updated>2020-02-12T05:27:26.266Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1581293738311-c1e14c2513dc?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>本文我们主要来了解redis和memcached的区别，以此深入了解redis为什么是单线程。</p><blockquote><p>开局一张图：客户端与 redis 的一次通信过程</p></blockquote><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/redis1/1.jpg" alt="客户端与 redis 的一次通信过程"></p><h2 id="redis-和-memcached-的区别"><a href="#redis-和-memcached-的区别" class="headerlink" title="redis 和 memcached 的区别"></a>redis 和 memcached 的区别</h2><p>对于 redis 和 memcached 我总结了下面四点。现在公司一般都是用 redis 来实现缓存，而且 redis 自身也越来越强大了！</p><ol><li><strong>redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li><li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</strong></li><li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li><li><strong>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</strong></li></ol><blockquote><p>来自网络上的一张图，这里分享给大家！</p></blockquote><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/61603179.jpg" alt="redis 和 memcached 的区别"></p><h2 id="redis为什么是单线程"><a href="#redis为什么是单线程" class="headerlink" title="redis为什么是单线程"></a>redis为什么是单线程</h2><blockquote><p>以下内容来自： <a href="https://www.zhihu.com/search?type=content&amp;q=redis为什么是单线程的" target="_blank" rel="noopener">知乎 - redis为什么是单线程</a> </p></blockquote><p>以前一直有个误区，以为：高性能服务器 一定是 多线程来实现的</p><p>原因很简单因为误区二导致的：多线程 一定比 单线程 效率高。其实不然。</p><p>在说这个事前希望大家都能对 CPU 、 内存 、 硬盘的速度都有了解了，这样可能理解得更深刻一点，不了解的朋友点：CPU到底比内存跟硬盘快多少</p><p>redis 核心就是 如果我的数据全都在内存里，我单线程的去操作 就是效率最高的，为什么呢，因为多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个CPU 绑定一块内存的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处理这个事。在内存的情况下，这个方案就是最佳方案 —— 阿里 沈询</p><p>因为一次CPU上下文的切换大概在 1500ns 左右。</p><p>从内存中读取 1MB 的连续数据，耗时大约为 250us，假设1MB的数据由多个线程读取了1000次，那么就有1000次时间上下文的切换，</p><p>那么就有1500ns * 1000 = 1500us ，我单线程的读完1MB数据才250us ,你光时间上下文的切换就用了1500us了，我还不算你每次读一点数据 的时间，</p><p>那什么时候用多线程的方案呢？</p><p>答案是：下层的存储等慢速的情况。比如磁盘</p><blockquote><p>IOPS (Input/Output Per Second)即每秒的输入输出量(或读写次数)，是衡量磁盘性能的主要指标之一。IOPS是指单位时间内系统能处理的I/O请求数量，I/O请求通常为读或写数据操作请求。随机读写频繁的应用，如OLTP(Online Transaction Processing)，IOPS是关键衡量指标。</p></blockquote><blockquote><p>另一个重要指标是数据吞吐量(Throughput)，指单位时间内可以成功传输的数据数量。对于大量顺序读写的应用，如VOD(Video On Demand)，则更关注吞吐量指标。</p></blockquote><p>内存是一个 IOPS （ 每秒的读写次数 ）非常高的系统，因为我想申请一块内存就申请一块内存，销毁一块内存我就销毁一块内存，内存的申请和销毁是很容易的。而且内存是可以动态的申请大小的。</p><p>磁盘的特性是：IOPS很低很低，但吞吐量很高。这就意味着，大量的读写操作都必须攒到一起，再提交到磁盘的时候，性能最高。为什么呢？</p><p>如果我有一个事务组的操作（就是几个已经分开了的事务请求，比如写读写读写，这么五个操作在一起），在内存中，因为IOPS非常高，我可以一个一个的完成，但是如果在磁盘中也有这种请求方式的话，</p><p>我第一个写操作是这样完成的：我先在硬盘中寻址，大概花费10ms，然后我读一个数据可能花费1ms然后我再运算（忽略不计），再写回硬盘又是10ms ，总共21ms</p><p>第二个操作去读花了10ms, 第三个又是写花费了21ms ,然后我再读10ms, 写21ms ，五个请求总共花费83ms，这还是最理想的情况下，这如果在内存中，大概1ms不到。</p><p>所以对于磁盘来说，它吞吐量这么大，那最好的方案肯定是我将N个请求一起放在一个buff里，然后一起去提交。</p><p>方法就是用异步：将请求和处理的线程不绑定，请求的线程将请求放在一个buff里，然后等buff快满了，处理的线程再去处理这个buff。然后由这个buff 统一的去写入磁盘，或者读磁盘，这样效率就是最高。java里的 IO不就是这么干的么~</p><p>对于慢速设备，这种处理方式就是最佳的，慢速设备有磁盘，网络 ，SSD 等等，</p><p>多线程 ，异步的方式处理这些问题非常常见，大名鼎鼎的netty 就是这么干的。</p><p>终于把 redis 为什么是单线程说清楚了，把什么时候用单线程跟多线程也说清楚了，其实也是些很简单的东西，只是基础不好的时候，就真的尴尬。。。。</p><p>补一发大师语录：来说说，为何单核cpu绑定一块内存效率最高</p><p>“我们不能任由操作系统负载均衡，因为我们自己更了解自己的程序，所以我们可以手动地为其分配CPU核，而不会过多地占用CPU”，默认情况下单线程在进行系统调用的时候会随机使用CPU内核，为了优化Redis，我们可以使用工具为单线程绑定固定的CPU内核，减少不必要的性能损耗！</p><p>redis作为单进程模型的程序，为了充分利用多核CPU，常常在一台server上会启动多个实例。而为了减少切换的开销，有必要为每个实例指定其所运行的CPU。</p><p>Linux 上 taskset 可以将某个进程绑定到一个特定的CPU。你比操作系统更了解自己的程序，为了避免调度器愚蠢的调度你的程序，或是为了在多线程程序中避免缓存失效造成的开销。</p><p>顺便再提一句：redis 的瓶颈在网络上 。。。。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h4 id="使用Redis有什么缺点？"><a href="#使用Redis有什么缺点？" class="headerlink" title="使用Redis有什么缺点？"></a><strong>使用Redis有什么缺点？</strong></h4><ul><li>缓存和数据库双写一致性问题</li><li>缓存雪崩问题</li><li>缓存击穿问题</li><li>缓存的并发竞争问题</li></ul><h4 id="单线程的Redis为什么这么快？"><a href="#单线程的Redis为什么这么快？" class="headerlink" title="单线程的Redis为什么这么快？"></a><strong>单线程的Redis为什么这么快？</strong></h4><ul><li>多路复用</li><li>Resp协议</li><li>单线程</li><li>内存操作</li></ul><p>（面试官会针对这几点详细提问）</p><h4 id="Redis的数据类型及使用场景（这5种类型你用到过几个？）"><a href="#Redis的数据类型及使用场景（这5种类型你用到过几个？）" class="headerlink" title="Redis的数据类型及使用场景（这5种类型你用到过几个？）"></a><strong>Redis的数据类型及使用场景</strong>（这5种类型你用到过几个？）</h4><p><strong>String：</strong>一般做一些复杂的计数功能的缓存；<br><strong>Hash：</strong>存储二维数据或对象；<br><strong>List：</strong>可实现队列，栈及有序的数据存储；<br><strong>Set：</strong>常用于黑名单，微信抽奖等功能，应用场景多变；<br><strong>SortedSet：</strong>做排行榜应用，取TOPN操作；延时任务；做范围查找。</p><h4 id="Redis过期策略和内存淘汰机制？"><a href="#Redis过期策略和内存淘汰机制？" class="headerlink" title="Redis过期策略和内存淘汰机制？"></a><strong>Redis过期策略和内存淘汰机制？</strong></h4><p>这个面试题，我只回答了定期删除，没答全，面试官提出一种惰性删除策略，有点懵，回去查了一下资料才搞明白；</p><h4 id="Redis和数据库双写一致性问题；"><a href="#Redis和数据库双写一致性问题；" class="headerlink" title="Redis和数据库双写一致性问题；"></a><strong>Redis和数据库双写一致性问题；</strong></h4><p>（最终一致性和强一致性）</p><h4 id="如何应对缓存穿透和缓存雪崩问题？"><a href="#如何应对缓存穿透和缓存雪崩问题？" class="headerlink" title="如何应对缓存穿透和缓存雪崩问题？"></a><strong>如何应对缓存穿透和缓存雪崩问题？</strong></h4><p>中小型的公司一般遇不到这些问题，但是大并发的项目，流量有几百万左右，这两个问题一定要深刻考虑。</p><h4 id="如何解决Redis并发竞争Key问题？"><a href="#如何解决Redis并发竞争Key问题？" class="headerlink" title="如何解决Redis并发竞争Key问题？"></a><strong>如何解决Redis并发竞争Key问题？</strong></h4><p>这个没答上来。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1581293738311-c1e14c2513dc?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1050&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="redis" scheme="https://lijinhongpassion.github.io/categories/redis/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
      <category term="redis" scheme="https://lijinhongpassion.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java-初探HBuilder开发APP</title>
    <link href="https://lijinhongpassion.github.io/codeant/hbuilder1.html"/>
    <id>https://lijinhongpassion.github.io/codeant/hbuilder1.html</id>
    <published>2020-02-02T06:03:08.000Z</published>
    <updated>2020-02-02T03:53:28.295Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1580489647132-f8a797717fa4?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1189&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>时隔几个月，中途都在找工作，没时间学习新东西，所以今天怀着好奇心，简单写个教程，供自己和大家一起查看，如果说有地方写的不对，欢迎大家来交谈。</p><h2 id="APP开发"><a href="#APP开发" class="headerlink" title="APP开发"></a>APP开发</h2><p>现在的安卓APP开发也无非是两种方式：</p><ul><li>原生安卓</li><li>H5</li></ul><p>之前我写过原生的安卓APP的demo，发现原生的安卓开发很繁琐（也因为自己原来十分的菜，当然现在也菜），后面一直想学习一下H5的APP开发，但是对于前端知识我一直不是很敏感，很排挤，所以一直就放下了。说远了，这里我就简单讲一下利用<code>hbuilder</code>开发一个<code>APP</code>并且安装到手机上的教程。<strong>这里不涉及到后端的开发</strong></p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>jdk8</td><td>利用jdk的keytool生成证书</td></tr><tr><td>hbuilderx或hbuilder</td><td>开发页面并打包</td></tr><tr><td>MUI</td><td>开发APP所用的前端框架，可以了解</td></tr><tr><td>真机安卓手机一台</td><td>测试</td></tr></tbody></table><h4 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h4><h5 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h5><p>创建前端项目，选择mui前端框架中的带有登录和设置的模板</p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/hbuilder1/1.png" alt></p><hr><h5 id="填写项目设置"><a href="#填写项目设置" class="headerlink" title="填写项目设置"></a>填写项目设置</h5><p>打开项目下的manifest.json，填写Dcloud appid，申请教程 <a href="https://ask.dcloud.net.cn/article/35907" target="_blank" rel="noopener">https://ask.dcloud.net.cn/article/35907</a> </p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/hbuilder1/2.png" alt></p><p>设置app图标</p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/hbuilder1/2.png" alt></p><hr><h5 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h5><p>这里我编写了一个bat脚本，该脚本运行的前提是 你的java环境变量配置好了</p><p>密钥生成的参考网址为：<a href="https://blog.csdn.net/weixin_42036591/article/details/88752679" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42036591/article/details/88752679</a></p><p><strong>记住输入的密钥口令，后面填写需要</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">@title 证书生成 -- 前提 jdk8</span><br><span class="line"></span><br><span class="line">rem 本脚本编写逻辑参考一下网址：https://blog.csdn.net/weixin_42036591/article/details/88752679</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> java_home=%JAVA_HOME%;</span><br><span class="line"></span><br><span class="line">rem 截取字符串，去除分号</span><br><span class="line">rem 进入java的bin目录下</span><br><span class="line"><span class="built_in">cd</span> /d %java_home:~0,-1%<span class="string">"/bin"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rem 开始生成证书</span><br><span class="line">rem keytool  -genkey  -<span class="built_in">alias</span>  证书别名  -keyalg  RSA   -validity 100 -keystore ceshi.keystore</span><br><span class="line">keytool  -genkey  -<span class="built_in">alias</span>  ceshi  -keyalg  RSA   -validity 100 -keystore ceshi.keystore</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"在打开的文件夹中搜索.keystore后缀的密钥文件"</span></span><br><span class="line">start <span class="string">""</span> %java_home:~0,-1%<span class="string">"/bin"</span></span><br><span class="line"> </span><br><span class="line">pause</span><br></pre></td></tr></table></figure><hr><h5 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h5><p>打包也有两种打包方式：</p><ul><li>云打包（推荐）</li><li>本地打包</li></ul><p>这里说一下云打包，发行-&gt;原生app-云打包</p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/hbuilder1/3.png" alt></p><hr><h5 id="打包成功"><a href="#打包成功" class="headerlink" title="打包成功"></a>打包成功</h5><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/hbuilder1/4.png" alt></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/hbuilder1/5.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1580489647132-f8a797717fa4?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1189&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://lijinhongpassion.github.io/categories/java/"/>
    
    
      <category term="Java" scheme="https://lijinhongpassion.github.io/tags/Java/"/>
    
      <category term="app" scheme="https://lijinhongpassion.github.io/tags/app/"/>
    
      <category term="hbuilder" scheme="https://lijinhongpassion.github.io/tags/hbuilder/"/>
    
      <category term="mui" scheme="https://lijinhongpassion.github.io/tags/mui/"/>
    
  </entry>
  
  <entry>
    <title>2019年下半年计划</title>
    <link href="https://lijinhongpassion.github.io/codeant/1231.html"/>
    <id>https://lijinhongpassion.github.io/codeant/1231.html</id>
    <published>2019-12-31T05:02:43.000Z</published>
    <updated>2019-10-12T01:23:34.781Z</updated>
    
    <content type="html"><![CDATA[<hr><p><blockquote><strong>2019下半年规划</strong></blockquote><br><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/1231/2019年度计划.png" alt="2019下半年规划"></p><p><blockquote>非常喜欢的视频，侵删！</blockquote></p><h2 id><a href="#" class="headerlink" title=" "></a><div style="position: relative;margin-bottom: 30px;float: left;width: 100%; height: 0;padding-bottom: 75%;"><iframe src="//player.youku.com/embed/XNDM4MzgxMzEzMg==" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute;width: 100%;height: 100%;left: 0;top: 0;"> </iframe></div></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;blockquote&gt;&lt;strong&gt;2019下半年规划&lt;/strong&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion
      
    
    </summary>
    
    
      <category term="年度计划" scheme="https://lijinhongpassion.github.io/tags/%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-Neo4j实战之入门案例理解neo4j</title>
    <link href="https://lijinhongpassion.github.io/codeant/neo4j2.html"/>
    <id>https://lijinhongpassion.github.io/codeant/neo4j2.html</id>
    <published>2019-11-14T07:16:10.000Z</published>
    <updated>2019-11-14T07:37:38.796Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1573666008508-3825beb91997?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1 简述"></a>1 简述</h2><p>本文只介绍一个例子，参照更多示例可以查看书本第二章</p><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2 示例"></a>2 示例</h2><p>假设人与人之间并不是一种朋友的关系，而你感兴趣的是人群之间的关联模型。一个组可能包含几个人，并且一个人也可能属于多个组。在传统的关系数据库中，通常会使用三个表的模型表达这种情景：一个人员表、一个组表和一个用于连接人和组的多对多关系链接表，如图2-1所示。</p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/neo4j2/2.1.1.png" alt></p><p>在Neo4j中，你可以将用户和组以同样的模型描述为节点，将组成员描述为节点之间的关系，如图2-2所示。</p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/neo4j2/2.1.2.png" style="zoom:50%;"></p><p>在这里你大致可以看到节点是图形数据库的数据模型实体（与RDBMS的术语对应），而关系勿庸置疑是节点之间的关系或连接。用纯语言表达这个图表的关系就是“一个人属于一个组”。</p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/neo4j2/2.1.3.png" style="zoom:50%;"></p><p>图2-2所示的模式出现在图2-3的几个地方。事实上，整个图2-3可以通过叠加几次图2-2得到。</p><p>当查询这个模型中的数据时，可能有两个问题需要回答。首先，对于一个给定的人，这个人属于哪个组？第二，对于一个给定的组，哪些人属于这个组？使用Neo4j的查询语言Cypher很容易实现。</p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/neo4j2/code1.png" alt></p><p>看上去这种模式适合我们的实例。通过从“一个人属于一个组”的简单关系开始，我们仅仅通过重复这种关系就能生成一个复杂的图形。我们最初的图2-2实际上代表了整个图形</p><p>对于更复杂的模型，有时按相反的方向思考更容易理解。可以首先在系统中画一张图把例子中所有不同的东西表示为节点，然后绘制箭头表示出这些节点之间的所有不同种类的关系。一旦开始看到重复的图案，就可以把它们拉出来并把它们归属为更小的图片单元。</p><h2 id="3-复杂示例"><a href="#3-复杂示例" class="headerlink" title="3 复杂示例"></a>3 复杂示例</h2><p>让我们多看几个不同的例子，看看它是如何分解成更小的图案的。在大型组织中，基于用户不同的角色、不同的任务和不同的组别授予其权限访问不同的系统。下面是用户可能具有的访问权限示例。</p><ul><li>直接的——你有权限访问共享文件系统中你自己文件夹中的文件。</li><li>基于某任务——作为数据库的管理员，你有权限连接到数据库控制台。</li><li>基于组成员——作为市场和销售团队的成员，你有权限连接到联系人管理系统。</li><li>基于对组所有成员指定的任务——作为一个开发团队的成员，所有的成员都有源代码控制提交的任务，都有权限从源代码库中取出代码并进行修改后返回原代码库。</li></ul><p>图2-4是一个未连接的授予这些权限的访问控制系统图。</p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/neo4j2/2.4.png" style="zoom:50%;"></p><p>图2-5显示了所绘实体之间可能存在的关系的同一图形。</p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/neo4j2/2.5.png" style="zoom:50%;"></p><p>正如你所看到的，有几种从用户到权限的可能路径。为了找出一个用户所拥有的权限，你需要找出一个用户节点通过任何途径连接的所有权限节点。在传统的关系数据库中，这需要一个复杂的查询表达每一个不同路径的join操作。</p><ul><li>从用户直接到权限（一表join操作）。</li><li>从用户到组再到权限（二表join操作）。</li><li>从用户到任务再到权限（二表join操作）。</li><li>从用户到组、到任务再到权限（三表join操作）。</li></ul><p>使用Cypher，一个短的查询即可实现：</p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/neo4j2/code2.png" alt></p><p>这将匹配任何第一个具有用户标签且其指定的属性值为姓名（name）的节点与第二个标记为权限节点的节点对，并且在它们之间有一个可以是任意长度的路径。最后，返回所有匹配了的权限名称。</p><p>现在假设你想对这个模型添加一个新功能，以反映组织的层次结构。用户不仅可以属于组，组还可以是较大组的下级组，例如，Tester、UXDesigner和Coder，可能隶属于开发组的小组。图2-6显示了在组之间具有下级组（subgroup_of）隶属关系扩展的新模型。</p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/neo4j2/2.6.png" style="zoom:50%;"></p><p>要改变关系数据库的查询以支持此模型的方案可不是一件容易的事，而最初模型的Cypher查询也完全适合这一扩展的模型，因为对用户查询一个权限与查询一个关系没有任何区别。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看见具体的案例过后，在关系复杂的实体类中，会发现确实比RDBMS方便很多，下一章节会对neo4j开发入门进行总结</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1573666008508-3825beb91997?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1050&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="neo4j" scheme="https://lijinhongpassion.github.io/categories/neo4j/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
      <category term="neo4j" scheme="https://lijinhongpassion.github.io/tags/neo4j/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-Neo4j实战之Neo4j概述</title>
    <link href="https://lijinhongpassion.github.io/codeant/neo4j1.html"/>
    <id>https://lijinhongpassion.github.io/codeant/neo4j1.html</id>
    <published>2019-11-14T07:11:00.000Z</published>
    <updated>2019-11-14T07:38:23.399Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1571942676558-281b2f9b1f8d?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1189&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><p>读书笔记</p><h2 id="1-简述neo4j"><a href="#1-简述neo4j" class="headerlink" title="1 简述neo4j"></a>1 简述neo4j</h2><h4 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h4><ul><li>图数据库</li><li>支持事务</li><li>nosql数据库</li></ul><h4 id="1-2-组成元素"><a href="#1-2-组成元素" class="headerlink" title="1.2 组成元素"></a>1.2 组成元素</h4><ul><li>节点（表示实体，例如用户）</li><li>关系（实体类之间的关系，例如朋友关系）</li><li>属性（节点和关系都具有属性，例如节点有名字属性、类型属性）</li></ul><p><strong>例子：</strong></p><p>有用户和地址两种类型的<strong>节点</strong>，用户节点有名字（name）、年龄（age）、喜欢的颜色(favoriteColor)三个<strong>属性</strong>，用户和地址之间有<code>has_address</code><strong>关系</strong>，关系有是否为现住址（is_current）的<strong>属性</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/neo4j1/relation.png" alt></p><h4 id="1-3-作用领域"><a href="#1-3-作用领域" class="headerlink" title="1.3 作用领域"></a>1.3 作用领域</h4><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/neo4j1/1.6.5.png" alt></p><h4 id="1-4-性能（参照书本1-4章节）"><a href="#1-4-性能（参照书本1-4章节）" class="headerlink" title="1.4 性能（参照书本1.4章节）"></a>1.4 性能（参照书本1.4章节）</h4><p>通过比较，在大数据的环境下，对于社交网络的遍历，关系型数据库明显弱于图数据库，原因如下：</p><ul><li><strong>图数据库进行的是局部遍历</strong></li></ul><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/neo4j1/1.4-mysql.png" alt></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/neo4j1/1.4-neo4j.png" alt></p><h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2 总结"></a>2 总结</h2><p>neo4j用户处理关系复杂的实体类，例如社交网络等，因为是<code>图</code>的数据结构，所以遍历（深度遍历和广度遍历）起来更加快速便捷，下一章节会举例说明。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1571942676558-281b2f9b1f8d?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1189&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="neo4j" scheme="https://lijinhongpassion.github.io/categories/neo4j/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
      <category term="neo4j" scheme="https://lijinhongpassion.github.io/tags/neo4j/"/>
    
  </entry>
  
  <entry>
    <title>Java-爬虫必备之正则表达式</title>
    <link href="https://lijinhongpassion.github.io/codeant/zzbd.html"/>
    <id>https://lijinhongpassion.github.io/codeant/zzbd.html</id>
    <published>2019-11-11T01:15:47.000Z</published>
    <updated>2019-11-11T04:04:26.661Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1573381970578-caaea2b66698?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="常用正则语法"><a href="#常用正则语法" class="headerlink" title="常用正则语法"></a>常用正则语法</h2><p> <strong>*，+，?，{}</strong>：匹配出现次数</p><table><thead><tr><th>字符</th><th>匹配格式</th></tr></thead><tbody><tr><td>*</td><td>{0，}</td></tr><tr><td>+</td><td>{1，}</td></tr><tr><td>？</td><td>{0，1}</td></tr><tr><td></td><td>{n,m}   最少n次，最多m次</td></tr></tbody></table><p><strong>[]，|，. ，\W，\w，\D，\d</strong>：匹配字符</p><table><thead><tr><th>字符</th><th>匹配格式</th></tr></thead><tbody><tr><td>[]</td><td>[A-Za-z]</td></tr><tr><td>\</td><td></td><td>(xy\</td><td>yx)等价于[(xy)(yx)]</td></tr><tr><td>.</td><td>匹配除<code>\n</code>以外的所有字符</td></tr><tr><td>\w</td><td>[A-Za-z0-9]</td></tr><tr><td>\W</td><td>[^A-Za-z0-9]</td></tr><tr><td>\d</td><td>[0-9]</td></tr><tr><td>\D</td><td>[^0-9]</td></tr></tbody></table><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/zzbd/1.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1573381970578-caaea2b66698?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1050&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://lijinhongpassion.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java-rabbitmq延时队列的实现（延时消费&amp;延时重试）</title>
    <link href="https://lijinhongpassion.github.io/codeant/rbtmq1.html"/>
    <id>https://lijinhongpassion.github.io/codeant/rbtmq1.html</id>
    <published>2019-10-16T09:51:23.000Z</published>
    <updated>2019-10-16T10:00:22.009Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1571198317078-76a4b545b2c1?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1073&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>阅读该部分的代码以及文章，必须了解的知识有：</p><ul><li>搭建安装好rabbitmq - server</li><li>rabbitmq 四种路由规则中的三种（direct、topic、fanout）</li></ul><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>本文代码地址：<a href="https://github.com/LiJinHongPassion/springboot/tree/master/springboot_rabbitmq_demo/rabbitmq-demo（延时队列）" target="_blank" rel="noopener">代码地址</a> </p><p>何为延迟队列？</p><p>顾名思义，延迟队列就是进入该队列的消息会被延迟消费的队列。而一般的队列，消息一旦入队了之后就会被消费者马上消费。</p><p>场景一：在订单系统中，一个用户下单之后通常有30分钟的时间进行支付，如果30分钟之内没有支付成功，那么这个订单将进行一场处理。这是就可以使用延时队列将订单信息发送到延时队列。</p><p>场景二：用户希望通过手机远程遥控家里的智能设备在指定的时间进行工作。这时候就可以将用户指令发送到延时队列，当指令设定的时间到了再将指令推送到只能设备。</p><h2 id="延迟队列能做什么？"><a href="#延迟队列能做什么？" class="headerlink" title="延迟队列能做什么？"></a>延迟队列能做什么？</h2><p>延迟队列多用于需要延迟工作的场景。最常见的是以下两种场景：</p><h4 id="延迟消费"><a href="#延迟消费" class="headerlink" title="延迟消费"></a><strong>延迟消费</strong></h4><p>比如：</p><ol><li>用户生成订单之后，需要过一段时间校验订单的支付状态，如果订单仍未支付则需要及时地关闭订单。</li><li>用户注册成功之后，需要过一段时间比如一周后校验用户的使用情况，如果发现用户活跃度较低，则发送邮件或者短信来提醒用户使用。</li></ol><h4 id="延迟重试"><a href="#延迟重试" class="headerlink" title="延迟重试"></a><strong>延迟重试</strong></h4><p>比如消费者从队列里消费消息时失败了，但是想要延迟一段时间后自动重试。</p><p>如果不使用延迟队列，那么我们只能通过一个轮询扫描程序去完成。这种方案既不优雅，也不方便做成统一的服务便于开发人员使用。但是使用延迟队列的话，我们就可以轻而易举地完成。</p><h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><p>别急，在下文中，我们将详细介绍如何利用Spring Boot加RabbitMQ来实现<strong>延迟消费</strong>和<strong>延迟重试</strong>队列。</p><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>在介绍具体的实现思路之前，我们先来介绍一下RabbitMQ的两个特性，一个是Time-To-Live Extensions，另一个是Dead Letter Exchanges。</p><p><strong>Time-To-Live Extensions</strong></p><p>RabbitMQ允许我们为消息或者队列设置TTL（time to live），也就是过期时间。TTL表明了一条消息可在队列中存活的最大时间，单位为毫秒。也就是说，当某条消息被设置了TTL或者当某条消息进入了设置了TTL的队列时，这条消息会在经过TTL秒后“死亡”，成为Dead Letter。如果既配置了消息的TTL，又配置了队列的TTL，那么较小的那个值会被取用。更多资料请查阅官方文档。</p><p><strong>Dead Letter Exchange</strong></p><p>刚才提到了，被设置了TTL的消息在过期后会成为Dead Letter。其实在RabbitMQ中，一共有三种消息的“死亡”形式：</p><ol><li>消息被拒绝。通过调用basic.reject或者basic.nack并且设置的requeue参数为false。</li><li>消息因为设置了TTL而过期。</li><li>消息进入了一条已经达到最大长度的队列。</li></ol><p>如果队列设置了Dead Letter Exchange（DLX），那么这些Dead Letter就会被重新publish到Dead Letter Exchange，通过Dead Letter Exchange路由到其他队列。更多资料请查阅官方文档。</p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p>将RabbitMQ的TTL和DLX特性结合在一起，实现一个延迟队列。</p><h5 id="延迟消费-1"><a href="#延迟消费-1" class="headerlink" title="延迟消费"></a><strong>延迟消费</strong></h5><p>延迟消费是延迟队列最为常用的使用模式。如下图所示，生产者产生的消息首先会进入缓冲队列（图中红色队列）。通过RabbitMQ提供的TTL扩展，这些消息会被设置过期时间，也就是延迟消费的时间。等消息过期之后，这些消息会通过配置好的DLX转发到实际消费队列（图中蓝色队列），以此达到延迟消费的效果。<br> <img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/rbtmq1/1延时消费.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/rbtmq1/2延时消费实际流程图.png" alt></p><p><strong>代码实现流程</strong></p><ul><li>创建queue、exchange、绑定路由规则 – QueueConfig.java</li><li>设置队列消息的过期时间 – ExpirationMessagePostProcessor.java</li><li>发送消息到exchange – ApplicationTests.java下的testDelayQueuePerMessageTTL()方法</li><li>从exchange接收消息 – ProcessReceiver.java</li></ul><p><strong>具体代码请参考：<a href="https://github.com/LiJinHongPassion/springboot/tree/master/springboot_rabbitmq_demo/rabbitmq-demo（延时队列）/延时消费" target="_blank" rel="noopener">https://github.com/LiJinHongPassion/springboot/tree/master/springboot_rabbitmq_demo/rabbitmq-demo（延时队列）/延时消费</a> </strong></p><p>方法一： <a href="https://github.com/LiJinHongPassion/springboot/tree/master/springboot_rabbitmq_demo/rabbitmq-demo（延时队列）/延时消费/springboot-rabbitmq-delay-message" target="_blank" rel="noopener">springboot-rabbitmq-delay-message</a> </p><p>方法二： <a href="https://github.com/LiJinHongPassion/springboot/tree/master/springboot_rabbitmq_demo/rabbitmq-demo（延时队列）/延时消费/springboot-rabbitmq-delay-queue" target="_blank" rel="noopener">springboot-rabbitmq-delay-queue</a> </p><hr><h5 id="延迟重试-1"><a href="#延迟重试-1" class="headerlink" title="延迟重试"></a><strong>延迟重试</strong></h5><p>延迟重试本质上也是延迟消费的一种，但是这种模式的结构与普通的延迟消费的流程图较为不同，所以单独拎出来介绍。</p><p>如下图所示，消费者发现该消息处理出现了异常，比如是因为网络波动引起的异常。那么如果不等待一段时间，直接就重试的话，很可能会导致在这期间内一直无法成功，造成一定的资源浪费。那么我们可以将其先放在缓冲队列中（图中红色队列），等消息经过一段的延迟时间后再次进入实际消费队列中（图中蓝色队列），此时由于已经过了“较长”的时间了，异常的一些波动通常已经恢复，这些消息可以被正常地消费。 <img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/rbtmq1/延时重试.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/rbtmq1/延时重试实际流程图.png" alt></p><p><strong>代码实现流程</strong></p><ul><li>创建queue、exchange、绑定路由规则、监听器 – QueueConfig.java</li><li>设置队列消息的过期时间（只针对方法二需要该文件） – ExpirationMessagePostProcessor.java</li><li>发送消息到exchange – ApplicationTests.java下的testFailMessage()方法</li><li>从exchange接收消息 – ProcessReceiver.java</li></ul><p><strong>具体代码请参考：<a href="https://github.com/LiJinHongPassion/springboot/tree/master/springboot_rabbitmq_demo/rabbitmq-demo（延时队列）/延时重试" target="_blank" rel="noopener">https://github.com/LiJinHongPassion/springboot/tree/master/springboot_rabbitmq_demo/rabbitmq-demo（延时队列）/延时重试</a> </strong></p><p>方法一： <a href="https://github.com/LiJinHongPassion/springboot/tree/master/springboot_rabbitmq_demo/rabbitmq-demo（延时队列）/延时重试/springboot-rabbitmq-delay-message" target="_blank" rel="noopener">springboot-rabbitmq-delay-message</a> </p><p>方法二： <a href="https://github.com/LiJinHongPassion/springboot/tree/master/springboot_rabbitmq_demo/rabbitmq-demo（延时队列）/延时重试/springboot-rabbitmq-delay-queue" target="_blank" rel="noopener">springboot-rabbitmq-delay-queue</a> </p><h4 id="查看测试结果"><a href="#查看测试结果" class="headerlink" title="查看测试结果"></a><strong>查看测试结果</strong></h4><h5 id="延迟消费场景"><a href="#延迟消费场景" class="headerlink" title="延迟消费场景"></a><strong>延迟消费场景</strong></h5><p>延迟消费的场景测试我们分为了TTL设置在消息上和TTL设置在队列上两种。首先，我们先看一下TTL设置在消息上的测试结果：</p><p><a href="https://files.jb51.net/file_images/article/201711/2017112111255062.gif" target="_blank" rel="noopener"><img src="https://files.jb51.net/file_images/article/201711/2017112111255062.gif" alt="动图点击查看"></a></p><p>从上图中我们可以看到，ProcessReceiver分别经过1秒、2秒、3秒收到消息。测试结果表明消息不仅被延迟消费了，而且每条消息的延迟时间是可以被个性化设置的。TTL设置在消息上的延迟消费场景测试成功。</p><p>然后，TTL设置在队列上的测试结果如下图：</p><p><a href="https://files.jb51.net/file_images/article/201711/2017112111255063.gif" target="_blank" rel="noopener"><img src="https://files.jb51.net/file_images/article/201711/2017112111255063.gif" alt="动图点击查看"></a> </p><p>从上图中我们可以看到，ProcessReceiver经过了4秒的延迟之后，同时收到了3条消息。测试结果表明消息不仅被延迟消费了，同时也证明了当TTL设置在队列上的时候，消息的过期时间是固定的。TTL设置在队列上的延迟消费场景测试成功。</p><hr><h5 id="延迟重试场景"><a href="#延迟重试场景" class="headerlink" title="延迟重试场景"></a><strong>延迟重试场景</strong></h5><p>接下来，我们再来看一下延迟重试的测试结果：</p><p><a href="https://files.jb51.net/file_images/article/201711/2017112111255064.gif" target="_blank" rel="noopener"><img src="https://files.jb51.net/file_images/article/201711/2017112111255064.gif" alt="动图点击查看"></a> </p><p>ProcessReceiver首先收到了3条会触发FAIL的消息，然后将其移动到缓冲队列之后，过了4秒，又收到了刚才的那3条消息。延迟重试场景测试成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是叙述了延时消费和延时重试，根据不同的应用场景，灵活运用两种方式，例如下订单的时候，我们可以两种方式结合起来用，延时消费 + 延时重试等等，是需要不同的应用场景的</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://www.jb51.net/article/128702.htm" target="_blank" rel="noopener">https://www.jb51.net/article/128702.htm</a>     Spring Boot与RabbitMQ结合实现延迟队列的示例</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1571198317078-76a4b545b2c1?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1073&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="rabbitmq" scheme="https://lijinhongpassion.github.io/categories/rabbitmq/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
      <category term="rabbitmq" scheme="https://lijinhongpassion.github.io/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>Java-Thread05之自定义线程池</title>
    <link href="https://lijinhongpassion.github.io/codeant/dxc05.html"/>
    <id>https://lijinhongpassion.github.io/codeant/dxc05.html</id>
    <published>2019-10-12T08:18:02.000Z</published>
    <updated>2019-10-12T08:36:20.400Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1570730739784-7c284457d15c?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="简述-自定义线程池（注意拒绝策略）"><a href="#简述-自定义线程池（注意拒绝策略）" class="headerlink" title="简述 - 自定义线程池（注意拒绝策略）"></a>简述 - 自定义线程池（注意拒绝策略）</h2><p>demo：<a href="https://github.com/LiJinHongPassion/ThreadTest" target="_blank" rel="noopener">https://github.com/LiJinHongPassion/ThreadTest</a></p><p>线程池的组成<br>一般的线程池主要分为以下 4 个组成部分：</p><pre><code>1. 线程池管理器：用于创建并管理线程池2. 工作线程：线程池中的线程3. 任务接口：每个任务必须实现的接口，用于工作线程调度其运行4. 任务队列：用于存放待处理的任务，提供一种缓冲机制</code></pre><hr><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc05/1.png" alt></p><p>观察之前提到的四种线程池的获取方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>其实最终返回的都是一个ThreadPoolExecutor，那么我们只要返回一个自定义的ThreadPoolExecutor就行了</strong></p><h2 id="ThreadPoolExecutor的构造函数"><a href="#ThreadPoolExecutor的构造函数" class="headerlink" title="ThreadPoolExecutor的构造函数"></a>ThreadPoolExecutor的构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参数解释：</p><pre><code>1. corePoolSize：指定了线程池中的线程数量。2. maximumPoolSize：指定了线程池中的最大线程数量。3. keepAliveTime：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁。4. unit：keepAliveTime 的单位。5. workQueue：任务队列，被提交但尚未被执行的任务。6. threadFactory：线程工厂，用于创建线程，一般用默认的即可。7. handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。</code></pre><h2 id="自定义线程池MyPool"><a href="#自定义线程池MyPool" class="headerlink" title="自定义线程池MyPool"></a><strong>自定义线程池MyPool</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述:自定义线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> LJH-1755497577 2019/10/12 14:55</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize 指定了线程池中的线程数量。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize 指定了线程池中的最大线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime 当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit keepAliveTime 的单位。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workQueue 任务队列，被提交但尚未被执行的任务。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 线程工厂，用于创建线程，一般用默认的即可。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 拒绝策略，当任务太多来不及处理，如何拒绝任务。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> java.util.concurrent.ThreadPoolExecutor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolExecutor <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 RejectedExecutionHandler handler)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyPool( corePoolSize,  maximumPoolSize,  keepAliveTime,</span><br><span class="line">                unit,  workQueue, threadFactory, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService poolExecutor = MyPool.getInstance(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; <span class="number">10</span>; a++)&#123;</span><br><span class="line">            poolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()  + <span class="string">"-----自定义线程池执行"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        poolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="重要参数讲解"><a href="#重要参数讲解" class="headerlink" title="重要参数讲解"></a>重要参数讲解</h2><h4 id="RejectedExecutionHandler-handler：拒绝策略"><a href="#RejectedExecutionHandler-handler：拒绝策略" class="headerlink" title="RejectedExecutionHandler handler：拒绝策略"></a>RejectedExecutionHandler handler：拒绝策略</h4><p>线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。<br>JDK 内置的拒绝策略如下：</p><pre><code>1. AbortPolicy ： 直接抛出异常，阻止系统正常运行。2. CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。3. DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。4. DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。</code></pre><p>以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展 RejectedExecutionHandler 接口。</p><p><strong>注意</strong>：之前的四种拒绝策略的默认为new AbortPolicy();</p><h4 id="BlockingQueue-workQueue：任务阻塞队列"><a href="#BlockingQueue-workQueue：任务阻塞队列" class="headerlink" title="BlockingQueue workQueue：任务阻塞队列"></a>BlockingQueue<runnable> workQueue：任务阻塞队列</runnable></h4><pre><code>1. ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。2. LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。3. PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。4. DelayQueue：使用优先级队列实现的无界阻塞队列。5. SynchronousQueue：不存储元素的阻塞队列。6. LinkedTransferQueue：由链表结构组成的无界阻塞队列。7. LinkedBlockingDeque：由链表结构组成的双向阻塞队列</code></pre><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc05/2.png" alt></p><p>阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况</p><ol><li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放<br>入队列。<br><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc05/3.png" alt></li><li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有<br>空的位置，线程被自动唤醒。<br><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc05/4.png" alt></li></ol><p>​    关于阻塞队列的详情需自行查阅百度</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1570730739784-7c284457d15c?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1050&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="多线程" scheme="https://lijinhongpassion.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
      <category term="多线程" scheme="https://lijinhongpassion.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-Thread04之四种线程池</title>
    <link href="https://lijinhongpassion.github.io/codeant/dxc04.html"/>
    <id>https://lijinhongpassion.github.io/codeant/dxc04.html</id>
    <published>2019-10-12T08:05:44.000Z</published>
    <updated>2019-10-12T08:30:22.083Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1556912998-c57cc6b63cd7?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="简述-四种线程池"><a href="#简述-四种线程池" class="headerlink" title="简述 - 四种线程池"></a>简述 - 四种线程池</h2><p>demo：<a href="https://github.com/LiJinHongPassion/ThreadTest" target="_blank" rel="noopener">https://github.com/LiJinHongPassion/ThreadTest</a></p><ol><li><p>线程池的概念：</p><p> 线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。</p></li><li><p>线程池的工作机制</p><p> 2.1 在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。</p><p> 2.1 一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</p></li><li><p><strong>使用线程池的原因：</strong></p><p> 多线程运行时间，系统不断的启动和关闭新线程，成本非常高，会过渡消耗系统资源，以及过渡切换线程的危险，从而可能导致系统资源的崩溃。这时，线程池就是最好的选择了。</p></li><li><p>线程池的组成</p><ol><li>线程池管理器：用于创建并管理线程池</li><li>工作线程：线程池中的线程</li><li>任务接口：每个任务必须实现的接口，用于工作线程调度其运行</li><li>任务队列：用于存放待处理的任务，提供一种缓冲机制</li></ol></li></ol><hr><p>Java 里面线程池的顶级接口是 Executor，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 ExecutorService。</p><ol><li>线程池的返回值ExecutorService简介：<br> ExecutorService是Java提供的用于管理线程池的类。该类的两个作用：控制线程数量和重用线程</li><li>具体的4种常用的线程池：（返回值都是ExecutorService）<ul><li>newCachedThreadPool</li><li>newFixedThreadPool</li><li>newScheduledThreadPool</li><li>newSingleThreadExecutor<br><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc04/threadpool.png" alt></li></ul></li></ol><hr><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将<strong>重用</strong>它们。<br>对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。<strong>调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。</strong>因此，长时间保持空闲的线程池不会使用任何资源。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">pool01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个可缓存线程池</span></span><br><span class="line">        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//sleep可明显看到使用的是线程池里面以前的线程，没有创建新的线程</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//打印正在执行的缓存线程信息</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"正在被执行"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        cachedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线程池为无限大，当执行当前任务时上一个任务已经完成，会复用执行上一个任务的线程，而不用每次新建线程</p><p><strong>执行结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1正在被执行</span><br><span class="line">pool-1-thread-1正在被执行</span><br><span class="line">pool-1-thread-1正在被执行</span><br><span class="line">pool-1-thread-1正在被执行</span><br><span class="line">pool-1-thread-1正在被执行</span><br><span class="line">pool-1-thread-1正在被执行</span><br><span class="line">pool-1-thread-1正在被执行</span><br><span class="line">pool-1-thread-1正在被执行</span><br><span class="line">pool-1-thread-1正在被执行</span><br><span class="line">pool-1-thread-1正在被执行</span><br></pre></td></tr></table></figure></p><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><p>创建一个<strong>可重用固定线程数的线程池</strong>，以共享的无界队列方式来运行这些线程。<br>在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">pool02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个可重用固定个数的线程池</span></span><br><span class="line">        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            fixedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//打印正在执行的缓存线程信息</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"正在被执行"</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        fixedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为线程池大小为3，每个任务输出打印结果后sleep 2秒，所以每两秒打印3个结果。<br>定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()</p><p><strong>执行结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1正在被执行</span><br><span class="line">pool-1-thread-2正在被执行</span><br><span class="line">pool-1-thread-3正在被执行</span><br><span class="line">pool-1-thread-1正在被执行</span><br><span class="line">pool-1-thread-3正在被执行</span><br><span class="line">pool-1-thread-2正在被执行</span><br><span class="line">pool-1-thread-1正在被执行</span><br><span class="line">pool-1-thread-3正在被执行</span><br><span class="line">pool-1-thread-2正在被执行</span><br><span class="line">pool-1-thread-1正在被执行</span><br></pre></td></tr></table></figure></p><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><p>创建一个定长线程池，<strong>支持定时及周期性任务执行</strong><br>ScheduledExecutorService</p><ul><li>schedule(Runnable, long, TimeUnit) – 延时执行（只执行一次）</li><li>schedule(Callable<v>, long, TimeUnit) – 延时执行</v></li><li>scheduleAtFixedRate(Runnable ,long ,long ,TimeUnit) – 周期执行</li><li>scheduleWithFixedDelay(Runnable ,long ,long ,TimeUnit) – 周期执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">pool03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 描述：延时执行（只执行一次）</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@author</span> LJH-1755497577 2019/10/12 13:35</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> command 执行线程</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> delay 延时</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> unit 计时单位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"延迟三秒执行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 描述：周期执行</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@author</span> LJH-1755497577 2019/10/12 13:35</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> command 执行线程</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> initialDelay 初始化延时</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> period 两次开始执行最小间隔时间</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> unit 计时单位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"延迟 1 秒后每三秒执行一次"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 描述：周期执行</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@author</span> LJH-1755497577 2019/10/12 13:35</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> command 执行线程</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> initialDelay 初始化延时</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> period 前一次执行结束到下一次执行开始的间隔时间（间隔执行延迟时间）</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> unit 计时单位</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        scheduledThreadPool.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"延迟 1 秒后每上一个线程执行完成后，间隔3秒，开始下一次线程执行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><p>创建一个单线程化的线程池（这个线程池只有一个线程），它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">pool04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个单线程化的线程池</span></span><br><span class="line">        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            singleThreadExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//结果依次输出，相当于顺序执行各个任务</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"正在被执行,打印的值是:"</span> + index);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        singleThreadExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>执行结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1正在被执行,打印的值是:0</span><br><span class="line">pool-1-thread-1正在被执行,打印的值是:1</span><br><span class="line">pool-1-thread-1正在被执行,打印的值是:2</span><br><span class="line">pool-1-thread-1正在被执行,打印的值是:3</span><br><span class="line">pool-1-thread-1正在被执行,打印的值是:4</span><br><span class="line">pool-1-thread-1正在被执行,打印的值是:5</span><br><span class="line">pool-1-thread-1正在被执行,打印的值是:6</span><br><span class="line">pool-1-thread-1正在被执行,打印的值是:7</span><br><span class="line">pool-1-thread-1正在被执行,打印的值是:8</span><br><span class="line">pool-1-thread-1正在被执行,打印的值是:9</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1556912998-c57cc6b63cd7?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1050&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="多线程" scheme="https://lijinhongpassion.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
      <category term="多线程" scheme="https://lijinhongpassion.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-Thread03之多线程线程状态</title>
    <link href="https://lijinhongpassion.github.io/codeant/dxc03.html"/>
    <id>https://lijinhongpassion.github.io/codeant/dxc03.html</id>
    <published>2019-10-12T07:58:36.000Z</published>
    <updated>2019-10-12T08:04:31.730Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1562101806-6a5f9ec69f41?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="简述-线程状态"><a href="#简述-线程状态" class="headerlink" title="简述 - 线程状态"></a>简述 - 线程状态</h2><p>demo：<a href="https://github.com/LiJinHongPassion/ThreadTest" target="_blank" rel="noopener">https://github.com/LiJinHongPassion/ThreadTest</a></p><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。</p><p>在线程的生命周期中，有几种状态呢？在API中 java.lang.Thread.State 这个枚举中给出了六种线程状态：<br>这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析<br><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc03/线程状态.png" alt></p><p>我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解这几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间的转换问题。</p><h4 id="提前了解-sleep和wait的区别"><a href="#提前了解-sleep和wait的区别" class="headerlink" title="提前了解 - sleep和wait的区别"></a>提前了解 - sleep和wait的区别</h4><ol><li>对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于Object 类中的。</li><li>sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。</li><li>在调用 <strong>sleep()</strong>方法的过程中，线程<strong>不会释放对象锁</strong>。</li><li>而当调用<strong> wait()</strong>方法的时候，线程<strong>会放弃对象锁</strong>，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</li></ol><h2 id="Timed-Waiting-（计时等待）"><a href="#Timed-Waiting-（计时等待）" class="headerlink" title="Timed Waiting （计时等待）"></a>Timed Waiting （计时等待）</h2><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。<br>单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)，那么我们通过一个案例加深对该状态的一个理解。<br><strong>实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串</strong><br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i) % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"‐‐‐‐‐‐‐"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//线程睡眠1秒，超时后自动唤醒</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.print(<span class="string">"    线程睡眠1秒！\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过案例可以发现， sleep方法的使用还是很简单的。我们需要记住下面几点：</p><ol><li>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。</li><li><strong>为了让其他线程有机会执行</strong>，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠</li><li>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。<br><blockquote>小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就<br>开始立刻执行。(这里我理解为线程调度的原因，例如时间片调度)</blockquote></li></ol><p><strong>执行过程</strong><br><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc03/timewaiting.png" alt></p><h2 id="BLOCKED-（锁阻塞）"><a href="#BLOCKED-（锁阻塞）" class="headerlink" title="BLOCKED （锁阻塞）"></a>BLOCKED （锁阻塞）</h2><p>Blocked 状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。<br>我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，而这部分内容作为扩充知识点带领大家了解一下。</p><p><strong>执行过程</strong><br><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc03/blocked.png" alt></p><h2 id="Waiting-（无限等待）"><a href="#Waiting-（无限等待）" class="headerlink" title="Waiting （无限等待）"></a>Waiting （无限等待）</h2><p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。<br>那么我们之前遇到过这种状态吗？答案是并没有。我们通过一段代码来学习一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 演示waiting</span></span><br><span class="line">        <span class="comment">//name:等待线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//                while (true) &#123;</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象"</span>);</span><br><span class="line">                            obj.wait();  <span class="comment">//无限等待</span></span><br><span class="line">                            <span class="comment">//obj.wait(5000); //计时等待, 5秒 时间到，自动醒来</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"=== 继续执行"</span>);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"=== 从waiting状态醒来，获取到锁对象，继续执行了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"等待线程"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//name:唤醒线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//while (true)&#123;   //每隔3秒 唤醒一次</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"‐‐‐‐‐ 等待3秒钟"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"‐‐‐‐‐ 获取到锁对象, 调用notify方法，释放锁对象"</span>);</span><br><span class="line">                    obj.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;, <span class="string">"唤醒线程"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的Object.notify()方法 或 Object.notifyAll()方法。</p><p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p><p>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。</p><p><strong>执行过程</strong><br><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc03/waiting.png" alt></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc03/others.png" alt></p><p>一条有意思的tips:<br>我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1562101806-6a5f9ec69f41?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1050&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="多线程" scheme="https://lijinhongpassion.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
      <category term="多线程" scheme="https://lijinhongpassion.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-Thread02之线程安全</title>
    <link href="https://lijinhongpassion.github.io/codeant/dxc02.html"/>
    <id>https://lijinhongpassion.github.io/codeant/dxc02.html</id>
    <published>2019-10-12T07:54:42.000Z</published>
    <updated>2019-10-12T07:59:41.071Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1570760295437-3627311f8fbe?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1046&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="简述-线程安全"><a href="#简述-线程安全" class="headerlink" title="简述 - 线程安全"></a>简述 - 线程安全</h2><p>demo：<a href="https://github.com/LiJinHongPassion/ThreadTest" target="_blank" rel="noopener">https://github.com/LiJinHongPassion/ThreadTest</a></p><p><strong>问题</strong><br>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。我们通过一个案例，演示线程的安全问题：<br>电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共100个(本场电影只能卖100张票)。我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票)需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟<br>模拟票：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作</span></span><br><span class="line">        <span class="comment">//窗口 永远开启</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//有票 可以卖</span></span><br><span class="line">                <span class="comment">//出票操作</span></span><br><span class="line">                <span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">"正在卖:"</span> + ticket‐‐);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">        <span class="comment">//创建线程任务对象        </span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();        </span><br><span class="line">        <span class="comment">//创建三个窗口对象        </span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口1"</span>);        </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口2"</span>);        </span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(ticket, <span class="string">"窗口3"</span>);        </span><br><span class="line">               </span><br><span class="line">        <span class="comment">//同时卖票        </span></span><br><span class="line">        t1.start();        </span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果中有一部分这样现象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">窗口3正在卖:5</span><br><span class="line">窗口3正在卖:4</span><br><span class="line">窗口1正在卖:3</span><br><span class="line">窗口2正在卖:4</span><br><span class="line">窗口1正在卖:2</span><br><span class="line">窗口3正在卖:0</span><br><span class="line">窗口3正在卖:-1</span><br><span class="line">窗口2正在卖:1</span><br></pre></td></tr></table></figure></p><p>发现程序出现了两个问题：</p><ol><li>相同的票数,比如5这张票被卖了两回。</li><li>不存在的票，比如0票与-1票，是不存在的。<br>这种问题，几个窗口(线程)<strong>票数不同步了</strong>，这种问题称为线程不安全。线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</li></ol><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制(synchronized)来解决。<br>根据案例简述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</span><br></pre></td></tr></table></figure></p><p>为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。<br>那么怎么去使用呢？有三种方式完成同步操作：</p><p><blockquote></blockquote></p><ol><li>同步代码块。</li><li>同步方法。</li><li>锁机制。<br></li></ol><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>同步代码块 ： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。<br>格式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">      需要同步操作的代码</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>同步锁:<br>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</p><ol><li>锁对象 可以是任意类型。</li><li>多个线程对象 要使用同一把锁。<br>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。<br>使用同步代码块解决代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;    </span><br><span class="line">    </span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();    </span><br><span class="line">    <span class="comment">/*    </span></span><br><span class="line"><span class="comment">    * 执行卖票操作    </span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="comment">//每个窗口卖票的操作         </span></span><br><span class="line">        <span class="comment">//窗口 永远开启         </span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;        </span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;            </span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖                </span></span><br><span class="line">                    <span class="comment">//出票操作                    </span></span><br><span class="line">                    <span class="comment">//使用sleep模拟一下出票时间                     </span></span><br><span class="line">                    <span class="keyword">try</span> &#123;                    </span><br><span class="line">                        Thread.sleep(<span class="number">50</span>);                        </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    </span><br><span class="line">                        e.printStackTrace();                        </span><br><span class="line">                    &#125;                    </span><br><span class="line">                    <span class="comment">//获取当前线程对象的名字                     </span></span><br><span class="line">                    String name = Thread.currentThread().getName();                    </span><br><span class="line">                    System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);                    </span><br><span class="line">                &#125;                </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。<br>格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/*可能会产生线程安全问题的代码*/</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>同步锁是谁?<br>对于非static方法,同步锁就是this。<br>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。<br>使用同步方法代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket02</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作         </span></span><br><span class="line">        <span class="comment">//窗口 永远开启         </span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 锁对象 是 谁调用这个方法 就是谁</span></span><br><span class="line"><span class="comment">     *   隐含 锁对象 就是  this</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//有票 可以卖  </span></span><br><span class="line">            <span class="comment">//出票操作</span></span><br><span class="line">            <span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto‐generated catch block  </span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name + <span class="string">"正在卖:"</span> + ticket‐‐);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock 锁"></a>Lock 锁</h4><p>java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p><ul><li>public void lock() :加同步锁。</li><li>public void unlock() :释放同步锁。<br>使用如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket03</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作         </span></span><br><span class="line">        <span class="comment">//窗口 永远开启         </span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//有票 可以卖</span></span><br><span class="line">                <span class="comment">//出票操作                 </span></span><br><span class="line">                <span class="comment">//使用sleep模拟一下出票时间                 </span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">"正在卖:"</span> + ticket--);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1570760295437-3627311f8fbe?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1046&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="多线程" scheme="https://lijinhongpassion.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
      <category term="多线程" scheme="https://lijinhongpassion.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-Thread01之创建线程</title>
    <link href="https://lijinhongpassion.github.io/codeant/dxc01.html"/>
    <id>https://lijinhongpassion.github.io/codeant/dxc01.html</id>
    <published>2019-10-12T07:50:28.000Z</published>
    <updated>2019-10-12T08:23:32.459Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1570749960335-08b0b98c26d0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="简述-线程创建"><a href="#简述-线程创建" class="headerlink" title="简述 - 线程创建"></a>简述 - 线程创建</h2><p>demo：<a href="https://github.com/LiJinHongPassion/ThreadTest" target="_blank" rel="noopener">https://github.com/LiJinHongPassion/ThreadTest</a></p><h2 id="四种创建方式分类"><a href="#四种创建方式分类" class="headerlink" title="四种创建方式分类"></a>四种创建方式分类</h2><p><strong>有返回值</strong></p><ul><li>实现callable接口</li><li></li></ul><p><strong>无返回值</strong></p><ul><li>继承 Thread 类</li><li>实现 Runnable 接口</li></ul><hr><p><strong>thread类api</strong></p><ul><li>继承 Thread 类</li><li>实现 Runnable 接口</li></ul><p><strong>线程池</strong></p><ul><li>实现callable接口</li><li></li></ul><hr><p><strong>Thread 类</strong><br>在上一天内容中我们已经可以完成最基本的线程开启，那么在我们完成操作过程中用到了 java.lang.Thread 类，API中该类中定义了有关线程的一些方法，具体如下：<br>构造方法：</p><ul><li>public Thread() :分配一个新的线程对象。</li><li>public Thread(String name) :分配一个指定名字的新的线程对象。</li><li>public Thread(Runnable target) :分配一个带有指定目标新的线程对象。</li><li>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。<br>常用方法：</li><li>public String getName() :获取当前线程名称。</li><li>public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。</li><li>public void run() :此线程要执行的任务在此处定义代码。</li><li>public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li><li>public static Thread currentThread() :返回对当前正在执行的线程对象的引用。<br>翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式，方式一我们上一天已经完成，接下来讲解方式二实现的方式。</li></ul><h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h2><p>Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThread.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line">MyThread myThread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">myThread1.start();</span><br></pre></td></tr></table></figure></p><h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><p>如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThread.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例：</span></span><br><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//事实上，当传入一个 Runnable target 参数给 Thread 后，Thread 的 run()方法就会调用target.run()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ExecutorService-、Callable-、Future-有返回值-线程"><a href="#ExecutorService-、Callable-、Future-有返回值-线程" class="headerlink" title="ExecutorService 、Callable 、Future 有返回值 线程"></a>ExecutorService 、Callable<class> 、Future 有返回值 线程</class></h2><p>有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。</p><h2 id="Thread-和Runnable的区别"><a href="#Thread-和Runnable的区别" class="headerlink" title="Thread 和Runnable的区别"></a>Thread 和Runnable的区别</h2><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。<br>总结：<br>实现Runnable接口比继承Thread类所具有的优势：</p><ol><li>适合多个相同的程序代码的线程去共享同一个资源。</li><li>可以避免java中的单继承的局限性。</li><li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li><li>线程池只能放入实现<strong>Runable或Callable类</strong>线程，不能直接放入继承Thread的类。<br><blockquote>扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</blockquote><h2 id="匿名内部类方式实现线程的创建"><a href="#匿名内部类方式实现线程的创建" class="headerlink" title="匿名内部类方式实现线程的创建"></a>匿名内部类方式实现线程的创建</h2>使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。<br>使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoNameInnerClassThread</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;            </span><br><span class="line"><span class="comment">// new Runnable()&#123;      </span></span><br><span class="line"><span class="comment">// public void run()&#123;          </span></span><br><span class="line"><span class="comment">// for (int i = 0; i &lt; 20; i++) &#123;              </span></span><br><span class="line"><span class="comment">// System.out.println("张宇:"+i);                  </span></span><br><span class="line"><span class="comment">// &#125;              </span></span><br><span class="line"><span class="comment">// &#125;            </span></span><br><span class="line"><span class="comment">//    &#125;; //‐‐‐这个整体  相当于new MyRunnable()    </span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"张宇:"</span>+i);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1570749960335-08b0b98c26d0?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1050&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="多线程" scheme="https://lijinhongpassion.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
      <category term="多线程" scheme="https://lijinhongpassion.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-Thread00之多线程知识准备</title>
    <link href="https://lijinhongpassion.github.io/codeant/dxc00.html"/>
    <id>https://lijinhongpassion.github.io/codeant/dxc00.html</id>
    <published>2019-10-12T07:30:12.000Z</published>
    <updated>2019-10-12T07:49:51.727Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1556740714-a8395b3bf30f?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1050&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>之前对多线程一直有排斥心理，每一次学一点点就放弃了，最近狠下心来从新学习，顺便做一个笔记，供大家参考一下。</p><p>demo：<a href="https://github.com/LiJinHongPassion/ThreadTest" target="_blank" rel="noopener">https://github.com/LiJinHongPassion/ThreadTest</a></p><h2 id="后期学习目录"><a href="#后期学习目录" class="headerlink" title="后期学习目录"></a>后期学习目录</h2><p>thread01：<a href="https://lijinhongpassion.github.io/codeant/dxc01.html">创建线程</a><br>thread02：<a href="https://lijinhongpassion.github.io/codeant/dxc02.html">线程安全（同步问题）</a><br>thread03：<a href="https://lijinhongpassion.github.io/codeant/dxc03.html">线程状态</a><br>thread04：<a href="https://lijinhongpassion.github.io/codeant/dxc04.html">四种线程池</a><br>thread05：<a href="https://lijinhongpassion.github.io/codeant/dxc05.html">自定义线程池</a></p><h2 id="提前了解"><a href="#提前了解" class="headerlink" title="提前了解"></a>提前了解</h2><h4 id="1-并发与并行"><a href="#1-并发与并行" class="headerlink" title="1 并发与并行"></a>1 并发与并行</h4><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li><li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li></ul><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc00/并行与并发.bmp" alt></p><p>在操作系统中，安装了多个程序，<strong>并发</strong>指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p><p>而在多个 CPU 系统中，则<strong>这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行</strong>，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p><blockquote><p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p></blockquote><h4 id="2-线程与进程"><a href="#2-线程与进程" class="headerlink" title="2 线程与进程"></a>2 线程与进程</h4><ul><li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p></li><li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p><p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p></li></ul><p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p><p><strong>进程</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc00/进程概念.png" alt></p><p><strong>线程</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc00/线程概念.png" alt></p><p><strong>线程调度:</strong></p><ul><li><p>分时调度</p><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p></li><li><p>抢占式调度</p><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p><ul><li>设置线程的优先级</li></ul><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc00/设置线程优先级.bmp" alt="设置线程优先级"></p><ul><li><p>抢占式调度详解</p><p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p><p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc00/抢占式调度.bmp" alt="抢占式调度"></p></li></ul></li></ul><h4 id="3-同步和异步"><a href="#3-同步和异步" class="headerlink" title="3 同步和异步"></a>3 同步和异步</h4><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dxc00/sync.png" alt="抢占式调度"></p><h4 id="4-同步锁和死锁"><a href="#4-同步锁和死锁" class="headerlink" title="4 同步锁和死锁"></a>4 同步锁和死锁</h4><p><strong>同步锁</strong><br>当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。</p><p><strong>死锁</strong><br>何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>学习文档\面试\4 JAVA.pdf中的多线程部分<br>学习文档\多线程\黑马程序员-异常 + 多线程基础中的多线程部分</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1556740714-a8395b3bf30f?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1050&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="多线程" scheme="https://lijinhongpassion.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
      <category term="多线程" scheme="https://lijinhongpassion.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java-SSM基础框架搭建（内含视频教学）</title>
    <link href="https://lijinhongpassion.github.io/codeant/dle7.html"/>
    <id>https://lijinhongpassion.github.io/codeant/dle7.html</id>
    <published>2019-10-02T00:29:27.000Z</published>
    <updated>2019-10-02T04:07:45.862Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1569916616603-cf060bff0cf5?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=992&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><p>##简述</p><p>今天主要讲诉一下ssm框架的搭建过程，由于springboot的广泛使用，很多人都忘记了怎么搭建ssm项目，这里做一个温习。</p><p><strong>demo地址：</strong><a href="https://github.com/LiJinHongPassion/ssmdemo2" target="_blank" rel="noopener">https://github.com/LiJinHongPassion/ssmdemo2</a></p><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul><li>温习ssm框架</li><li>学习ssm框架，从而加深对springboot项目的灵活使用</li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><table><thead><tr><th>名称</th><th>版本</th></tr></thead><tbody><tr><td>idea</td><td>2019</td></tr><tr><td>jdk</td><td>1.8</td></tr><tr><td>tomcat</td><td>8.5</td></tr><tr><td>maven</td><td>3.5</td></tr><tr><td>mysql</td><td>5.7</td></tr></tbody></table><h4 id="spring的请求方式"><a href="#spring的请求方式" class="headerlink" title="spring的请求方式"></a>spring的请求方式</h4><p>首先我们需要知道一个http请求是怎么经过spring的处理后得到响应的。</p><p><img src="https://img-blog.csdn.net/20161229134539820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemd6Y3p6dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>了解了请求的处理过程，下面开始搭建项目。</p><p>因为idea需要初始化项目索引，所以会导致很卡，会很吃内存。</p><p>配置ssm主要涉及到下面几个配置文件：</p><ul><li>spring-mvc.xml  mvc配置</li><li>spring-mybatis.xml  整合mybatis</li><li>jdbc.properties  数据库连接池的属性配置</li><li>web.xml</li></ul><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p>这里项目结构不对，需要重新添加需要的文件夹，完成后如下：</p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dle7/1.png" alt></p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>修改pom.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.2.6<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring核心包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-oxm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis核心包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis/spring包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导入java ee jar 包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javaee-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导入Mysql数据库链接jar包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 导入dbcp的jar包，用来在applicationContext.xml中配置数据库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbcp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbcp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 映入JSON --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.jackson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-mapper-asl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上传组件包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="spring-mvc-xml配置"><a href="#spring-mvc-xml配置" class="headerlink" title="spring-mvc.xml配置"></a>spring-mvc.xml配置</h4><p>添加依赖后，开始配置项目，先配置mvc</p><p>主要配置下面几个方面：</p><ul><li>静态资源访问权限</li><li>开启注解</li><li>视图解析</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                        http://www.springframework.org/schema/context/spring-context-3.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--静态资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/pic/**"</span> <span class="attr">location</span>=<span class="string">"/pic/"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.cqut.li.test_ssm.controller"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mappingJacksonHttpMessageConverter"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html;charset=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageConverters"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"mappingJacksonHttpMessageConverter"</span>/&gt;</span>    <span class="comment">&lt;!-- JSON转换器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 默认编码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"utf-8"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 文件大小最大值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"10485760000"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 内存中的最大值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInMemorySize"</span> <span class="attr">value</span>=<span class="string">"40960"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="spring-mybatis-xml配置"><a href="#spring-mybatis-xml配置" class="headerlink" title="spring-mybatis.xml配置"></a>spring-mybatis.xml配置</h4><p>该配置文件主要是用于整合mybatis，主要配置以下内容：</p><ul><li>数据库连接池</li><li>事务</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                        http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                        http://www.springframework.org/schema/context/spring-context-3.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">                        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描，扫描标注了service、repository等注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.cqut.li.test_ssm.*"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"propertyConfigurer"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">value</span>=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 初始化连接大小 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;initialSize&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接池最大数量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"$&#123;maxActive&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接池最大空闲 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"$&#123;maxIdle&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接池最小空闲 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"$&#123;minIdle&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 获取连接最大等待时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWait"</span> <span class="attr">value</span>=<span class="string">"$&#123;maxWait&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自动扫描mapping.xml文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mapping/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.cqut.li.test_ssm.dao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="jdbc-properties配置"><a href="#jdbc-properties配置" class="headerlink" title="jdbc.properties配置"></a>jdbc.properties配置</h4><p>下面需要配置jdbc配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">driver=com.mysql.jdbc.Driver</span><br><span class="line">#url=jdbc:mysql://127.0.0.1:3306/laboratory?useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">#url=jdbc:mysql://superc102.vicp.cc:3307/laboratory?useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">url=jdbc\:mysql\://127.0.0.1\:3306/financialtest?useUnicode\=true&amp;characterEncoding\=utf8</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br><span class="line">#定义初始连接数</span><br><span class="line">initialSize=1</span><br><span class="line">#定义最大连接数</span><br><span class="line">maxActive=20</span><br><span class="line">#定义最大空闲</span><br><span class="line">maxIdle=20</span><br><span class="line">#定义最小空闲</span><br><span class="line">minIdle=1</span><br><span class="line">#定义最大等待</span><br><span class="line">maxWait=60000</span><br><span class="line">#处理超时断开连接而没有销毁的情况</span><br><span class="line">#验证查询语句</span><br><span class="line">validationQuery=SELECT COUNT(*) FROM role</span><br><span class="line">#周期性检测-半个小时</span><br><span class="line">timeBetweenEvictionRunsMillis=1800000</span><br><span class="line">#连接空闲时间 --半个小时</span><br><span class="line">minEvictableIdleTimeMillis=1800000</span><br><span class="line">#取得对象时是否进行验证，检查对象是否有效</span><br><span class="line">testOnBorrow=true</span><br><span class="line">#返回对象时是否进行验证，检查对象是否有效</span><br><span class="line">testOnReturn=true</span><br><span class="line">#空闲时是否进行验证，检查对象是否有效</span><br><span class="line">testWhileIdle=true</span><br></pre></td></tr></table></figure><h4 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h4><p>主要配置以下内容：</p><ul><li>spring容器</li><li>编码过滤器</li><li>mvc分发器</li><li>spring监听器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载配置文件，初始化容器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 编码过滤器，过滤乱码 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>spring监听器<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 防止spring内存溢出监听器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.util.IntrospectorCleanupListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- spring mvc servlet 分发器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- DEFAULT PAGE --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="项目启动配置"><a href="#项目启动配置" class="headerlink" title="项目启动配置"></a>项目启动配置</h4><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dle7/2.png" alt></p><h2 id="项目导入-amp-测试（视频）"><a href="#项目导入-amp-测试（视频）" class="headerlink" title="项目导入&amp;测试（视频）"></a>项目导入&amp;测试（视频）</h2><div style="position: relative;margin-bottom: 30px;float: left;width: 100%; height: 0;padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=69732312&cid=120835662&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute;width: 100%;height: 100%;left: 0;top: 0;"> </iframe></div>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1569916616603-cf060bff0cf5?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=992&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://lijinhongpassion.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
      <category term="ssm" scheme="https://lijinhongpassion.github.io/tags/ssm/"/>
    
  </entry>
  
  <entry>
    <title>Java-springboot+jsp部署问题</title>
    <link href="https://lijinhongpassion.github.io/codeant/dle0.html"/>
    <id>https://lijinhongpassion.github.io/codeant/dle0.html</id>
    <published>2019-09-26T08:39:11.000Z</published>
    <updated>2019-09-27T07:41:42.068Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1556745757-8d76bdb6984b?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=966&amp;q=80" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>今天打包项目的时候遇见一个问题，首先我的项目是基于springboot + jsp，打包的时候我发现jsp以及相关的静态资源都没有打包进jar包，所以我就百度查阅相关解决方案，这里给出一种我成功解决的方法。</p><h2 id="springboot打包结构"><a href="#springboot打包结构" class="headerlink" title="springboot打包结构"></a>springboot打包结构</h2><p>这是打包后的jar包的目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">zf-0.0.1-SNAPSHOT</span><br><span class="line">    ├─BOOT-INF//java代码</span><br><span class="line">    │  ├─classes</span><br><span class="line">    │  │  │  application.yml</span><br><span class="line">    │  │  ├─com</span><br><span class="line">    │  │  │  └─zf</span><br><span class="line">    │  │  │      └─admin</span><br><span class="line">    │  │  │          ├─comment</span><br><span class="line">    │  │  │          ├─conf</span><br><span class="line">    │  │  │          ├─controller</span><br><span class="line">    │  │  │          ├─dao</span><br><span class="line">    │  │  │          ├─pojo</span><br><span class="line">    │  │  │          ├─service</span><br><span class="line">    │  │  │          │  └─Impl </span><br><span class="line">    │  │  │          └─utils</span><br><span class="line">    │  │  │              ├─image</span><br><span class="line">    │  │  │              ├─jwt</span><br><span class="line">    │  │  │              ├─mail</span><br><span class="line">    │  │  │              ├─mybatis</span><br><span class="line">    │  │  │              └─verificationcode       </span><br><span class="line">    │  │  └─mapping</span><br><span class="line">    │  └─lib</span><br><span class="line">    │          </span><br><span class="line">    ├─META-INF//静态资源</span><br><span class="line">    │  ├─maven</span><br><span class="line">    │  │  └─com.zf.admin</span><br><span class="line">    │  │      └─zf</span><br><span class="line">    │  └─resources</span><br><span class="line">    │      ├─css</span><br><span class="line">    │      ├─fonts</span><br><span class="line">    │      ├─images</span><br><span class="line">    │      ├─js</span><br><span class="line">    │      │  ├─libs</span><br><span class="line">    │      │  └─localization</span><br><span class="line">    │      └─WEB-INF</span><br><span class="line">    │          ├─jsp</span><br><span class="line">    │          │  └─admin</span><br><span class="line">    │          └─tld</span><br><span class="line">    └─org</span><br><span class="line">        └─springframework</span><br><span class="line">            └─boot</span><br><span class="line">                └─loader</span><br><span class="line">                    ├─archive </span><br><span class="line">                    ├─data</span><br><span class="line">                    ├─jar</span><br><span class="line">                    └─util</span><br></pre></td></tr></table></figure><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/LiJinHongPassion.github.io/master/codeant/dle0/1.png" alt></p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>pom文件里面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        SpringBoot打包成jar在服务器上无法访问JSP页面问题--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>META-INF/resources<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--版本号一定是1.4.2--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1556745757-8d76bdb6984b?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=966&amp;amp;q=80&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://lijinhongpassion.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
      <category term="springboot" scheme="https://lijinhongpassion.github.io/tags/springboot/"/>
    
      <category term="jsp" scheme="https://lijinhongpassion.github.io/tags/jsp/"/>
    
  </entry>
  
  <entry>
    <title>Java-实体类中使用包装类和基本类型的区别（转载）</title>
    <link href="https://lijinhongpassion.github.io/codeant/4aff.html"/>
    <id>https://lijinhongpassion.github.io/codeant/4aff.html</id>
    <published>2019-09-20T10:59:23.000Z</published>
    <updated>2019-09-20T15:09:03.912Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://images.unsplash.com/photo-1556909212-d5b604d0c90d?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=500&amp;q=60" alt></p><a id="more"></a><center><br><br>​    <span id="m_name"></span><br><br>​    <audio id="m_url_id" controls> <source src> <source src="horse.ogg" type="audio/ogg"> Your browser does not support this audio format.<br><br>​    </audio><br><br></center>  <hr><h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><p><strong>QQ：1755497577（备注：博客）</strong></p><p><strong>B站：code_ant（java相关培训视频）</strong></p><p><img src="https://raw.githubusercontent.com/LiJinHongPassion/springboot/master/wechat.png" alt="微信搜索公众号：CodeAnt"></p><hr><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>最近面试的时候，面试官提的一个问题，在实体类（pojo）中是使用包装类还是基本类型？为什么？</p><p>我知道使用包装类型比较好，但是却忘记了好在哪里了。其实关于好在哪里，也不过就是需要把包装类和基本类型搞清楚。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>首先,分析各自的优缺点：</p><h4 id="基本类型-以int类型为例子"><a href="#基本类型-以int类型为例子" class="headerlink" title="基本类型(以int类型为例子)"></a>基本类型(以int类型为例子)</h4><p><strong>优点</strong></p><ol><li><p>用于计算时效率高</p></li><li><p>不会由于常量池引起比较大小的错误(例如java integer对象判断两个数字是否相等)</p></li></ol><p><strong>缺点</strong></p><ol><li><p>当数据库中查询出结果之后封装结果集的时候，如果返回的值时null时,直接赋值给这个基本类型的字段时,会在运行时报出异常,不能将null赋给一个基本类型,而用Integer就不存在这样都的情况，这个情况暂时没有合适的避免办法.当没有默认值的情况下</p></li><li><p>当页面传来的值是只有字段没有值时或者没有传来对应字段对象时候，赋值给基本类型的值时就会抛出异常.(如：如果表单中没有对应字段存在，那么request中换取到一个为null的值)</p></li></ol><p><strong>缺点的规避方法：</strong><br>a. 设置在数据库中为该字段设置默认值。<br>b. 当用这个字段没有在表单中被提交时就会报错。</p><hr><h4 id="包装类型-Integer"><a href="#包装类型-Integer" class="headerlink" title="包装类型(Integer)"></a>包装类型(Integer)</h4><p><strong>优点</strong></p><ol><li>可以存放null,从数据库中查出值时可能会有null</li></ol><p><strong>缺点</strong></p><ol><li>不能用于两个Integer对象双等的方式来判断两个对象的值相等,会出现错误的。</li></ol><p><strong>缺点规避方法：</strong><br>a. 要用双等判断两个对象的值是否相等时,可以通过调用intValue方法来实现。</p><p>因此，综上所说，实体类采用包装类型比较好。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/78590948" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/78590948</a> 有了基本数据类型，为什么还需要包装类型</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1556909212-d5b604d0c90d?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=500&amp;amp;q=60&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://lijinhongpassion.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://lijinhongpassion.github.io/tags/java/"/>
    
  </entry>
  
</feed>
